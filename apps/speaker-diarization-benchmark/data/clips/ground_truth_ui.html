<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ground Truth Creator</title>
    <style>
        body { font-family: system-ui, sans-serif; max-width: 95%; margin: 0 auto; padding: 20px; background: #f4f4f9; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { margin-top: 0; }
        audio { width: 100%; margin: 20px 0; }
        #transcript { 
            display: flex; 
            gap: 20px; 
            overflow-x: auto; 
        }
        .model-column { 
            flex: 1; 
            min-width: 300px; 
            background: #fff; 
            padding: 10px; 
            border-radius: 4px; 
            border: 1px solid #ddd;
            height: calc(100vh - 250px); /* Fixed height for scrolling */
            overflow-y: auto; /* Enable vertical scrolling */
        }
        .segment { 
            display: block;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            transition: all 0.2s;
            cursor: pointer; /* Indicates the whole card is clickable (for seeking) */
        }
        .segment:hover { 
            background: #fcfcfc; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .segment.active { 
            background: #f0f7ff; 
            border-left: 4px solid #2196f3; 
            border-color: #bbdefb;
        }
        
        .segment-header {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85em;
            color: #666;
        }
        
        .segment-text {
            display: block;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: text;
            background: rgba(0,0,0,0.02);
            transition: background 0.1s;
            line-height: 1.4;
        }
        .segment-text:hover {
            background: #eee;
        }
        
        .speaker-label {
            font-weight: bold;
            color: #333;
            margin-right: 8px;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .speaker-label:hover {
            background: #e0e0e0;
        }
        
        .timestamp {
            color: #888;
            margin-right: 8px;
            font-family: monospace;
        }
        .controls { margin-bottom: 20px; }
        button { padding: 8px 16px; cursor: pointer; background: #2196f3; color: white; border: none; border-radius: 4px; }
        button:hover { background: #1976d2; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Ground Truth Creator</h1>
        
        <div class="controls">
            <select id="clip-select" onchange="loadClipById(this.value)" style="padding: 8px; border-radius: 4px; max-width: 400px;">
                <option value="">Select Clip...</option>
            </select>
            <button id="save-btn" onclick="saveData()" style="background-color: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Save Ground Truth</button>
            <button onclick="showUnlabeled()" style="background-color: #FF9800; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">Unlabeled Speakers</button>
            <span id="status" style="margin-left: 10px; color: #666;"></span>
        </div>

        <div id="player-container" style="display:none;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <h3 id="clip-title" style="margin: 0;"></h3>
                <a id="youtube-link" href="#" target="_blank" style="display: none; color: #f00; font-weight: bold; text-decoration: none;">Watch on YouTube ↗</a>
            </div>
            <div id="clip-meta" style="color: #666; font-size: 0.9em; margin-bottom: 10px;"></div>
            
            <div id="speaker-map" style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 4px;">
                <!-- Speaker inputs will go here -->
            </div>

            <audio id="audio" controls></audio>
            
            <div id="transcript"></div>
        </div>
        
        <!-- Unlabeled Speakers Modal/View -->
        <div id="unlabeled-view" style="display:none; margin-top: 20px; border-top: 1px solid #ccc; padding-top: 20px;">
            <h2>Unlabeled Speakers Dashboard</h2>
            <div id="unlabeled-list"></div>
        </div>
        
        <datalist id="known-speakers"></datalist>
    </div>

    <script>
        let manifestData = [];
        let currentClip = null;
        let speakerMap = {}; // SPEAKER_00 -> "Ilya Sutskever"

        const audio = document.getElementById('audio');
        const transcriptDiv = document.getElementById('transcript');
        const speakerMapDiv = document.getElementById('speaker-map');
        const statusSpan = document.getElementById('status');
        const clipSelect = document.getElementById('clip-select');
        const clipTitle = document.getElementById('clip-title');
        const clipMeta = document.getElementById('clip-meta');
        const youtubeLink = document.getElementById('youtube-link');
        const unlabeledView = document.getElementById('unlabeled-view');
        const unlabeledList = document.getElementById('unlabeled-list');
        const knownSpeakersList = document.getElementById('known-speakers');

        function updateKnownSpeakers() {
            knownSpeakersList.innerHTML = '';
            const uniqueNames = new Set();
            
            // 1. Add from current session map
            Object.values(speakerMap).forEach(name => uniqueNames.add(name));
            
            // 2. Add from all clips in manifest
            if (manifestData && manifestData.length > 0) {
                manifestData.forEach(clip => {
                    if (clip.transcriptions) {
                        Object.values(clip.transcriptions).forEach(segments => {
                            if (Array.isArray(segments)) {
                                segments.forEach(seg => {
                                    if (seg.speaker) uniqueNames.add(seg.speaker);
                                });
                            }
                        });
                    }
                });
            }

            Array.from(uniqueNames).sort().forEach(name => {
                // Filter out machine-generated IDs
                if (!name || name.startsWith('SEG_SPK_') || name.startsWith('SPEAKER_') || name.startsWith('UNKNOWN_')) return;
                const option = document.createElement('option');
                option.value = name;
                knownSpeakersList.appendChild(option);
            });
        }

        // Auto-load data
        window.onload = loadData;

        // Unified ontimeupdate handler
        audio.ontimeupdate = () => {
            updateHighlights();
        };

        function updateHighlights() {
            const time = audio.currentTime;
            
            // 1. Highlight active speaker in list
            let activeSpeaker = null;
            if (currentClip && currentClip.transcriptions) {
                const models = Object.keys(currentClip.transcriptions);
                let bestModel = models[0];
                if (models.includes('mlx_whisper_turbo_seg_level')) bestModel = 'mlx_whisper_turbo_seg_level';
                else if (models.includes('mlx_whisper_turbo')) bestModel = 'mlx_whisper_turbo';
                else if (models.includes('pywhispercpp.small')) bestModel = 'pywhispercpp.small';

                const segments = currentClip.transcriptions[bestModel] || [];
                for (const seg of segments) {
                    if (time >= seg.start && time <= seg.end) {
                        activeSpeaker = seg.speaker;
                        break;
                    }
                }
            }
            
            document.querySelectorAll('.speaker-row').forEach(row => {
                row.style.backgroundColor = 'transparent';
                if (activeSpeaker && row.dataset.speaker === activeSpeaker) {
                    row.style.backgroundColor = '#e8f5e9'; // Light green
                }
            });

            // 2. Highlight active segment in transcript
            document.querySelectorAll('.segment').forEach(seg => {
                const start = parseFloat(seg.dataset.start);
                const end = parseFloat(seg.dataset.end);
                
                if (time >= start && time < end) {
                    if (!seg.classList.contains('active')) {
                        seg.classList.add('active'); // Use .active instead of .active-segment to match CSS
                        
                        // Auto-scroll to center
                        seg.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    seg.classList.remove('active');
                }
            });
        }

        async function loadData() {
            try {
                console.log("Fetching manifest.json...");
                const response = await fetch('manifest.json');
                manifestData = await response.json();
                console.log("Manifest loaded:", manifestData);
                
                // Populate select
                clipSelect.innerHTML = '<option value="">Select Clip...</option>';
                manifestData.forEach(clip => {
                    const option = document.createElement('option');
                    option.value = clip.id;
                    // Enhanced Dropdown Label
                    const title = clip.title || clip.id;
                    const range = clip.start_time !== undefined ? `(${clip.start_time}s - ${clip.start_time + clip.duration}s)` : '';
                    option.textContent = `${title} ${range}`;
                    clipSelect.appendChild(option);
                });

                if (manifestData.length > 0) {
                    const lastClipId = localStorage.getItem('lastClipId');
                    const clipToLoad = manifestData.find(c => c.id === lastClipId) || manifestData[0];
                    loadClip(clipToLoad);
                    clipSelect.value = clipToLoad.id;
                } else {
                    statusSpan.textContent = "No clips found in manifest.";
                }
            } catch (e) {
                console.error(e);
                statusSpan.textContent = "Error loading manifest.json. Make sure you are running a local server.";
            }
        }
        
        function loadClipById(id) {
            const clip = manifestData.find(c => c.id === id);
            if (clip) {
                loadClip(clip);
                unlabeledView.style.display = 'none';
                document.getElementById('player-container').style.display = 'block';
            }
        }

        function loadClip(clipData) {
            console.log("loadClip called with:", clipData);
            currentClip = clipData;
            localStorage.setItem('lastClipId', clipData.id);
            document.getElementById('player-container').style.display = 'block';
            
            // Update Title and Metadata
            clipTitle.textContent = clipData.title || clipData.id;
            clipMeta.textContent = `ID: ${clipData.id} | Duration: ${clipData.duration}s`;
            
            // Update YouTube Link
            if (clipData.original_url && clipData.original_url.includes('youtube')) {
                youtubeLink.style.display = 'block';
                // Append timestamp
                const timeParam = clipData.start_time ? `&t=${Math.floor(clipData.start_time)}s` : '';
                youtubeLink.href = clipData.original_url + timeParam;
            } else {
                youtubeLink.style.display = 'none';
            }
            
            audio.src = clipData.id; 
            
            // Initialize speaker map from existing data
            // Only reset if loading a new clip, but here we are loading a clip so yes.
            speakerMap = {};
            const speakers = new Set();
            if (clipData.transcriptions) {
                 Object.values(clipData.transcriptions).forEach(segments => {
                     segments.forEach(s => {
                         if (s.speaker) speakers.add(s.speaker);
                     });
                 });
            }
            
            // Initialize map with identity
            Array.from(speakers).sort().forEach(spk => {
                speakerMap[spk] = spk;
            });

            updateKnownSpeakers();
            renderSpeakerInputs();
            renderTranscriptions(clipData.transcriptions);
        }
        
        function renderSpeakerInputs() {
            speakerMapDiv.innerHTML = '<strong>Identify Speakers:</strong><br>';
            const speakers = Object.keys(speakerMap).sort();
            
            speakers.forEach(originalSpk => {
                const row = document.createElement('div');
                row.className = 'speaker-row';
                row.dataset.speaker = originalSpk;
                row.style.marginTop = '5px';
                row.style.padding = '4px';
                row.style.borderRadius = '4px';
                
                const label = document.createElement('span');
                label.textContent = originalSpk + ': ';
                label.style.width = '150px';
                label.style.display = 'inline-block';
                label.style.fontWeight = 'bold';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = 'Enter Name';
                input.value = speakerMap[originalSpk];
                input.oninput = (e) => {
                    speakerMap[originalSpk] = e.target.value;
                    renderTranscriptions(currentClip.transcriptions);
                };
                
                row.appendChild(label);
                row.appendChild(input);
                speakerMapDiv.appendChild(row);
            });
        }
        
        function showUnlabeled() {
            document.getElementById('player-container').style.display = 'none';
            unlabeledView.style.display = 'block';
            unlabeledList.innerHTML = '';
            
            // Find all unlabeled speakers across all clips
            const unlabeled = [];
            manifestData.forEach(clip => {
                if (!clip.transcriptions) return;
                
                const models = Object.keys(clip.transcriptions);
                let bestModel = models[0];
                if (models.includes('mlx_whisper_turbo_seg_level')) bestModel = 'mlx_whisper_turbo_seg_level';
                else if (models.includes('mlx_whisper_turbo')) bestModel = 'mlx_whisper_turbo';
                else if (models.includes('pywhispercpp.small')) bestModel = 'pywhispercpp.small';
                
                const segments = clip.transcriptions[bestModel] || [];
                const clipSpeakers = new Set();
                segments.forEach(s => {
                    if (s.speaker && s.speaker.startsWith('SPEAKER_')) {
                        clipSpeakers.add(s.speaker);
                    }
                });
                
                clipSpeakers.forEach(spk => {
                    unlabeled.push({ clip: clip, speaker: spk });
                });
            });
            
            if (unlabeled.length === 0) {
                unlabeledList.textContent = "No unlabeled speakers found! Great job!";
                return;
            }
            
            unlabeled.forEach(item => {
                const div = document.createElement('div');
                div.style.marginBottom = '10px';
                div.style.padding = '10px';
                div.style.background = '#fff';
                div.style.border = '1px solid #ddd';
                div.style.borderRadius = '4px';
                
                // Find first segment for this speaker
                const models = Object.keys(item.clip.transcriptions);
                let bestModel = models[0];
                if (models.includes('mlx_whisper_turbo_seg_level')) bestModel = 'mlx_whisper_turbo_seg_level';
                else if (models.includes('mlx_whisper_turbo')) bestModel = 'mlx_whisper_turbo';
                else if (models.includes('pywhispercpp.small')) bestModel = 'pywhispercpp.small';

                const segments = item.clip.transcriptions[bestModel] || [];
                const firstSeg = segments.find(s => s.speaker === item.speaker);
                
                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.alignItems = 'center';
                header.style.marginBottom = '5px';
 
                const title = document.createElement('strong');
                title.textContent = `${item.speaker} in ${item.clip.title || item.clip.id}`;
                title.style.marginRight = '10px';
                
                const playBtn = document.createElement('button');
                playBtn.textContent = "▶ Play Sample";
                playBtn.style.marginRight = '10px';
                playBtn.style.cursor = 'pointer';
                playBtn.onclick = () => {
                    audio.src = item.clip.id;
                    audio.currentTime = firstSeg.start;
                    audio.play();
                };
 
                const labelBtn = document.createElement('button');
                labelBtn.textContent = "Label This Clip";
                labelBtn.style.cursor = 'pointer';
                labelBtn.onclick = () => {
                    loadClip(item.clip);
                    clipSelect.value = item.clip.id;
                    unlabeledView.style.display = 'none';
                };
                
                header.appendChild(title);
                header.appendChild(playBtn);
                header.appendChild(labelBtn);
                div.appendChild(header);
                
                if (firstSeg) {
                    const preview = document.createElement('div');
                    preview.style.fontSize = '0.9em';
                    preview.style.color = '#666';
                    preview.style.fontStyle = 'italic';
                    preview.textContent = `"${firstSeg.text}"`;
                    div.appendChild(preview);
                }
                
                unlabeledList.appendChild(div);
            });
        }
        
        async function saveData() {
            if (!currentClip) return;
            
            statusSpan.textContent = "Enrolling...";
            
            try {
                await fetch('/enroll', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        clip_id: currentClip.id,
                        mapping: speakerMap
                    })
                });
            } catch (e) {
                console.error("Enrollment failed:", e);
            }
 
            if (currentClip.transcriptions) {
                 Object.values(currentClip.transcriptions).forEach(segments => {
                     segments.forEach(s => {
                         if (s.speaker && speakerMap[s.speaker]) {
                             s.speaker = speakerMap[s.speaker];
                         }
                     });
                 });
            }
            
            statusSpan.textContent = "Saving...";
            
            try {
                const response = await fetch('/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(manifestData)
                });
                
                if (response.ok) {
                    statusSpan.textContent = "Saved!";
                    setTimeout(() => statusSpan.textContent = "", 2000);
                    loadClip(currentClip); 
                } else {
                    statusSpan.textContent = "Error saving.";
                }
            } catch (e) {
                console.error(e);
                statusSpan.textContent = "Error saving: " + e.message;
            }
        }
 
        let navigationSegments = [];
 
        function renderTranscriptions(transcriptions) {
            console.log("renderTranscriptions called with:", transcriptions);
            transcriptDiv.innerHTML = '';
            if (!transcriptions) {
                console.warn("No transcriptions found for this clip.");
                transcriptDiv.innerHTML = '<em>No transcriptions available.</em>';
                return;
            }

            // Dynamically get all model keys
            const models = Object.keys(transcriptions);
            console.log("Available models:", models);
            
            // Prioritize mlx_whisper_turbo_seg_level, then mlx_whisper_turbo, else first available
            let navModel = models[0];
            if (models.includes('mlx_whisper_turbo_seg_level')) navModel = 'mlx_whisper_turbo_seg_level';
            else if (models.includes('mlx_whisper_turbo')) navModel = 'mlx_whisper_turbo';
            
            console.log("Selected navModel:", navModel);

            if (navModel && transcriptions[navModel]) {
                navigationSegments = transcriptions[navModel].sort((a, b) => a.start - b.start);
            }
 
            models.forEach(modelName => {
                console.log("Processing model:", modelName);
                if (!transcriptions[modelName]) return;
                
                const col = document.createElement('div');
                col.className = 'model-column';
                
                const header = document.createElement('h3');
                header.textContent = modelName;
                col.appendChild(header);
                
                // Metadata Display
                if (currentClip.transcription_metadata && currentClip.transcription_metadata[modelName]) {
                    const meta = currentClip.transcription_metadata[modelName];
                    const metaDiv = document.createElement('div');
                    metaDiv.style.fontSize = '0.75em';
                    metaDiv.style.color = '#666';
                    metaDiv.style.marginBottom = '10px';
                    metaDiv.style.padding = '5px';
                    metaDiv.style.background = '#f9f9f9';
                    metaDiv.style.border = '1px solid #eee';
                    metaDiv.style.borderRadius = '4px';
                    
                    let html = `<strong>Pipeline:</strong> ${meta.pipeline}<br>`;
                    html += `<strong>Commit:</strong> ${meta.commit_hash.substring(0, 7)}`;
                    if (meta.is_dirty) html += ' (dirty)';
                    html += `<br><strong>Params:</strong> T=${meta.threshold}, W=${meta.window}, C=${meta.cluster_threshold}, ID=${meta.id_threshold}`;
                    if (meta.timestamp) html += `<br><strong>Date:</strong> ${meta.timestamp}`;
                    
                    metaDiv.innerHTML = html;
                    col.appendChild(metaDiv);
                }
                
                const segments = transcriptions[modelName];
                console.log(`Found ${segments.length} segments for ${modelName}`);

                segments.forEach((seg, index) => {
                    const p = document.createElement('div');
                    p.className = 'segment';
                    p.dataset.start = seg.start;
                    p.dataset.end = seg.end;
                    
                    // Card Click -> Seek
                    p.onclick = (e) => {
                        // Prevent seeking if clicking on an input/textarea
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                        console.log("Seeking to:", seg.start);
                        if (Number.isFinite(seg.start)) {
                            audio.currentTime = seg.start;
                            audio.play().catch(err => console.error("Play failed:", err));
                        }
                    };
                    
                    // --- HEADER (Time + Speaker) ---
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'segment-header';
                    
                    // Timestamp
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'timestamp';
                    timeSpan.textContent = `[${seg.start.toFixed(1)} - ${seg.end.toFixed(1)}]`;
                    headerDiv.appendChild(timeSpan);
                    
                    // Speaker Label
                    const speakerSpan = document.createElement('span');
                    const displaySpeaker = speakerMap[seg.speaker] || seg.speaker;
                    speakerSpan.textContent = displaySpeaker ? `${displaySpeaker}` : 'UNKNOWN';
                    speakerSpan.className = 'speaker-label';
                    speakerSpan.title = "Click to edit speaker name";
                    
                    // Speaker Edit Click
                    speakerSpan.onclick = (e) => {
                        console.log("Speaker label clicked (editing mode)");
                        e.stopPropagation(); 
                        audio.pause(); 
                        
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.onclick = (e) => e.stopPropagation();
                        
                        const currentValue = speakerMap[seg.speaker] || seg.speaker;
                        input.value = currentValue;
                        input.dataset.original = currentValue;
                        input.setAttribute('list', 'known-speakers');
                        input.setAttribute('autocomplete', 'off');
                        input.style.width = '150px';
                        input.style.marginRight = '5px';
                        
                        headerDiv.replaceChild(input, speakerSpan);
                        
                        input.onfocus = () => { input.value = ''; };
                        input.focus();
                        input.click();
                        
                        let saved = false;
                        const revert = () => { renderTranscriptions(currentClip.transcriptions); };

                        const save = async (triggerPlay = false) => {
                            if (saved) return;
                            saved = true;
                            
                            let newName = input.value.trim();
                            newName = newName.replace(':', '').trim();
                            
                            if (newName) {
                                if (currentClip.transcriptions[modelName] && currentClip.transcriptions[modelName][index]) {
                                    currentClip.transcriptions[modelName][index].speaker = newName;
                                }

                                const isMachineID = (s) => s.startsWith('SPEAKER_') || s.startsWith('SEG_SPK_') || s.startsWith('UNKNOWN');
                                if (isMachineID(seg.speaker)) {
                                    speakerMap[seg.speaker] = newName;
                                }
                                speakerMap[newName] = newName;

                                updateKnownSpeakers(); 
                                renderSpeakerInputs();
                                renderTranscriptions(currentClip.transcriptions);
                                
                                if (modelName === 'mlx_whisper_turbo_seg_level') {
                                    try {
                                        await fetch('/correct_segment', {
                                            method: 'POST',
                                            headers: {'Content-Type': 'application/json'},
                                            body: JSON.stringify({
                                                clip_id: currentClip.id,
                                                segment_index: index,
                                                new_label: newName
                                            })
                                        });
                                    } catch (e) { console.error("Correction error:", e); }
                                }
                                
                                if (triggerPlay) audio.play();
                            } else {
                                revert();
                            }
                        };

                        input.onkeydown = (e) => {
                            if (e.key === 'Enter') { e.preventDefault(); save(true); } 
                            else if (e.key === 'Escape') { e.preventDefault(); saved = true; revert(); }
                        };
                        input.onchange = () => { save(true); };
                        input.onblur = () => { if (!saved) revert(); };
                    };
                    
                    headerDiv.appendChild(speakerSpan);
                    p.appendChild(headerDiv);
                    
                    // --- TEXT BODY ---
                    const textDiv = document.createElement('div');
                    textDiv.className = 'segment-text';
                    textDiv.textContent = seg.text;
                    textDiv.title = "Click to edit text";
                    
                    // Text Edit Click
                    textDiv.onclick = (e) => {
                        e.stopPropagation();
                        audio.pause();

                        const textarea = document.createElement('textarea');
                        textarea.value = seg.text.trim();
                        textarea.style.width = '100%';
                        textarea.style.minHeight = '60px';
                        textarea.style.fontFamily = 'inherit';
                        textarea.style.fontSize = 'inherit';
                        textarea.style.padding = '4px';
                        textarea.style.border = '1px solid #2196f3';
                        textarea.style.borderRadius = '4px';
                        
                        p.replaceChild(textarea, textDiv);
                        textarea.focus();
                        
                        let saved = false;
                        
                        const saveText = () => {
                            if (saved) return;
                            saved = true;
                            
                            const newText = textarea.value;
                            const lines = newText.split('\n').map(l => l.trim()).filter(l => l);
                            
                            if (lines.length === 0) { renderTranscriptions(currentClip.transcriptions); return; }
                            
                            if (lines.length === 1) {
                                if (lines[0] !== seg.text.trim()) {
                                    currentClip.transcriptions[modelName][index].text = lines[0];
                                    saveData();
                                }
                                renderTranscriptions(currentClip.transcriptions);
                            } else {
                                statusSpan.textContent = "Splitting...";
                                fetch('/split_segment', {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({
                                        clip_id: currentClip.id,
                                        segment_index: index,
                                        lines: lines,
                                        model_name: modelName
                                    })
                                })
                                .then(r => r.json())
                                .then(data => {
                                    currentClip.transcriptions[modelName].splice(index, 1, ...data.segments);
                                    statusSpan.textContent = "Split saved!";
                                    setTimeout(() => statusSpan.textContent = "", 2000);
                                    renderTranscriptions(currentClip.transcriptions);
                                })
                                .catch(err => {
                                    console.error("Error splitting:", err);
                                    renderTranscriptions(currentClip.transcriptions);
                                });
                            }
                        };

                        textarea.onblur = saveText;
                        textarea.onkeydown = (e) => {
                            if (e.key === 'Escape') { saved = true; renderTranscriptions(currentClip.transcriptions); }
                        };
                        
                        textarea.style.height = (textarea.scrollHeight) + 'px';
                    };
                    
                    p.appendChild(textDiv);
                    col.appendChild(p);
                });
                
                transcriptDiv.appendChild(col);
            });
            
            // Apply highlights immediately after render
            updateHighlights();
        }

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in an input or editing text
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

            if (e.code === 'Space') {
                e.preventDefault();
                if (audio.paused) audio.play();
                else audio.pause();
            } else if (e.code === 'ArrowLeft' || e.code === 'ArrowUp') {
                e.preventDefault();
                navigate(-1);
            } else if (e.code === 'ArrowRight' || e.code === 'ArrowDown') {
                e.preventDefault();
                navigate(1);
            } else if (e.code === 'Enter') {
                e.preventDefault();
                // Find active segment and trigger edit
                const activeSeg = document.querySelector('.active-segment');
                if (activeSeg) {
                    const speakerLabel = activeSeg.querySelector('.speaker-label');
                    if (speakerLabel) {
                        speakerLabel.click();
                    }
                }
            }
        });

        function navigate(direction) {
            if (!navigationSegments.length) return;
            
            const time = audio.currentTime;
            // Find current segment index
            // We find the segment that contains the current time, or the one just before it
            let currentIndex = -1;
            
            for (let i = 0; i < navigationSegments.length; i++) {
                const seg = navigationSegments[i];
                if (time >= seg.start && time < seg.end) {
                    currentIndex = i;
                    break;
                }
                // If we are in between segments (silence), finding the last one that ended before now
                if (time < seg.start) {
                    // This segment starts after current time, so the previous one was the "current" context
                    currentIndex = i - 1;
                    break;
                }
            }
            
            // If we reached the end without finding one, we might be after the last segment
            if (currentIndex === -1 && time >= navigationSegments[navigationSegments.length - 1].end) {
                currentIndex = navigationSegments.length - 1;
            }

            let newIndex = currentIndex + direction;
            
            // Boundary checks
            if (newIndex < 0) newIndex = 0;
            if (newIndex >= navigationSegments.length) newIndex = navigationSegments.length - 1;
            
            const targetSeg = navigationSegments[newIndex];
            if (targetSeg) {
                audio.currentTime = targetSeg.start;
                audio.play();
            }
        }
    </script>
</body>
</html>
