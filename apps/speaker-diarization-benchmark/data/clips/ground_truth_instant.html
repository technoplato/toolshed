<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ground Truth (InstantDB - New Schema)</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        max-width: 95%;
        margin: 0 auto;
        padding: 20px;
        background: #f4f4f9;
      }
      .container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      .controls {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        min-width: 200px;
      }
      button {
        padding: 8px 16px;
        cursor: pointer;
        background: #2196f3;
        color: white;
        border: none;
        border-radius: 4px;
      }
      button:hover {
        background: #1976d2;
      }

      #layout {
        display: flex;
        gap: 20px;
        overflow-x: auto;
      }

      /* Debug panel - positioned at far right of columns */
      #debug-column {
        flex: 0 0 350px;
        min-width: 350px;
        max-width: 400px;
        order: 999; /* Always last */
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
        height: calc(100vh - 250px);
      }
      #debug-column .col-header {
        padding: 10px;
        border-bottom: 1px solid #eee;
        background: #f9f9f9;
        font-weight: bold;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      #debug-dump {
        flex: 1;
        overflow: auto;
        margin: 0;
        padding: 10px;
        background: #f8f8f8;
        font-size: 0.75em;
        border: none;
        border-radius: 0;
      }
      .column {
        flex: 1;
        min-width: 300px;
        background: #fff;
        border: 1px solid #ddd; /* Match model-column border */
        border-radius: 4px;
        display: flex;
        flex-direction: column;
        height: calc(100vh - 250px); /* Height match */
      }
      .col-header {
        padding: 10px;
        border-bottom: 1px solid #eee;
        background: #f9f9f9;
        font-weight: bold;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .col-content {
        flex: 1;
        overflow-y: auto;
        padding: 10px;
      }

      /* Polished Segment Card */
      .segment {
        display: block;
        background: #fff;
        border: 1px solid #eee;
        border-radius: 6px;
        padding: 10px;
        margin-bottom: 8px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        transition: all 0.2s;
        cursor: pointer;
      }
      .segment:hover {
        background: #fcfcfc;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .segment.active {
        background: #f0f7ff;
        border-left: 4px solid #2196f3;
        border-color: #bbdefb;
      }

      .segment-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
        font-size: 0.85em;
        color: #666;
      }

      .segment-text {
        display: block;
        padding: 8px 10px;
        border-radius: 4px;
        cursor: text;
        background: rgba(0, 0, 0, 0.02);
        transition: all 0.15s;
        line-height: 1.5;
        color: #333;
        border: 1px solid transparent;
      }
      .segment-text:hover {
        background: #f5f5f5;
        border-color: #ddd;
      }
      .segment-text:active {
        background: #e3f2fd;
        border-color: #2196f3;
      }

      .seg-speaker {
        font-weight: bold;
        color: #333;
        cursor: pointer;
        padding: 2px 8px;
        border-radius: 3px;
        background: #e8f5e9;
        margin-right: 10px;
      }
      .seg-speaker:hover {
        background: #c8e6c9;
      }
      .seg-speaker.unlabeled {
        background: #fff3e0;
        color: #e65100;
      }
      .seg-speaker.unlabeled:hover {
        background: #ffe0b2;
      }

      .timestamp {
        color: #888;
        font-family: monospace;
        font-size: 0.85em;
      }

      .segment-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
      }

      /* Loading overlay */
      #loading {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      /* Speaker autocomplete dropdown */
      .speaker-autocomplete {
        position: relative;
        display: inline-block;
      }
      .speaker-autocomplete input {
        width: 180px;
        padding: 6px 10px;
        border: 2px solid #2196f3;
        border-radius: 4px;
        font-size: 0.9em;
      }
      .speaker-autocomplete input:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
      }
      .autocomplete-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        max-height: 200px;
        overflow-y: auto;
        background: white;
        border: 1px solid #ddd;
        border-top: none;
        border-radius: 0 0 4px 4px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        z-index: 100;
      }
      .autocomplete-item {
        padding: 8px 10px;
        cursor: pointer;
        font-size: 0.9em;
      }
      .autocomplete-item:hover,
      .autocomplete-item.selected {
        background: #e3f2fd;
      }
      .autocomplete-item.current-video {
        border-left: 3px solid #4caf50;
        background: #f1f8e9;
      }
      .autocomplete-item.current-video:hover,
      .autocomplete-item.current-video.selected {
        background: #dcedc8;
      }
      .autocomplete-section {
        padding: 4px 10px;
        font-size: 0.75em;
        color: #666;
        background: #f5f5f5;
        font-weight: bold;
        border-top: 1px solid #eee;
      }

      /* Shortcuts help panel */
      #shortcuts-panel {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 12px 16px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        font-size: 0.85em;
        z-index: 50;
        max-width: 280px;
      }
      #shortcuts-panel h4 {
        margin: 0 0 10px 0;
        font-size: 0.9em;
        color: #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #shortcuts-panel .toggle-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.2em;
        padding: 0;
        color: #666;
      }
      .shortcut-list {
        display: none;
      }
      .shortcut-list.expanded {
        display: block;
      }
      .shortcut-row {
        display: flex;
        justify-content: space-between;
        padding: 4px 0;
        border-bottom: 1px solid #f0f0f0;
      }
      .shortcut-row:last-child {
        border-bottom: none;
      }
      .shortcut-key {
        font-family: monospace;
        background: #f5f5f5;
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #ddd;
        font-size: 0.9em;
      }
      .shortcut-desc {
        color: #666;
      }

      /* Active segment has keyboard focus indicator */
      .segment.active {
        outline: 2px solid #2196f3;
        outline-offset: 1px;
      }

      /* Optimistic update indicator */
      .segment.optimistic-update {
        opacity: 0.7;
        position: relative;
      }
      .segment.optimistic-update::after {
        content: "‚è≥";
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 0.8em;
      }

      /* Toast notifications */
      #toast-container {
        position: fixed;
        bottom: 80px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .toast {
        padding: 12px 20px;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        font-size: 0.9em;
        animation: slideIn 0.3s ease-out;
        max-width: 350px;
      }
      .toast.success {
        background: #4caf50;
        color: white;
      }
      .toast.error {
        background: #f44336;
        color: white;
      }
      .toast.info {
        background: #2196f3;
        color: white;
      }
      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }

      /* Cluster visualization */
      .cluster-badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: bold;
        margin-left: 8px;
      }

      .cluster-0 {
        background: #e3f2fd;
        color: #1565c0;
      }
      .cluster-1 {
        background: #f3e5f5;
        color: #7b1fa2;
      }
      .cluster-2 {
        background: #e8f5e9;
        color: #2e7d32;
      }
      .cluster-3 {
        background: #fff3e0;
        color: #ef6c00;
      }
      .cluster-4 {
        background: #fce4ec;
        color: #c2185b;
      }
      .cluster-5 {
        background: #e0f7fa;
        color: #00838f;
      }
      .cluster-noise {
        background: #f5f5f5;
        color: #757575;
      }

      .cluster-representative {
        border: 2px solid gold !important;
        box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
      }

      .cluster-group {
        border-left: 4px solid;
        margin-bottom: 16px;
        padding-left: 12px;
      }

      .cluster-group-header {
        font-weight: bold;
        padding: 8px;
        margin-bottom: 8px;
        border-radius: 4px;
      }

      #clusterBtn {
        background: #9c27b0;
        color: white;
      }

      #clusterBtn:hover {
        background: #7b1fa2;
      }

      #clusterBtn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .cluster-stats {
        background: #f5f5f5;
        padding: 12px;
        border-radius: 8px;
        margin: 12px 0;
      }

      /* Resume Auto-scroll Button */
      #resumeAutoScrollBtn {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #2196f3;
        color: white;
        padding: 12px 24px;
        border-radius: 24px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        display: none;
      }

      #resumeAutoScrollBtn:hover {
        background: #1976d2;
      }
    </style>
    <!-- <script type="module" src="https://js.instantdb.com/v0.12.7/client.js"></script> -->
  </head>
  <body>
    <div id="loading">Loading...</div>
    <div id="toast-container"></div>

    <!-- Keyboard Shortcuts Help Panel -->
    <div id="shortcuts-panel">
      <h4>
        ‚å®Ô∏è Shortcuts
        <button class="toggle-btn" onclick="toggleShortcuts()">‚ñº</button>
      </h4>
      <div class="shortcut-list" id="shortcut-list">
        <div class="shortcut-row">
          <span class="shortcut-key">Enter</span>
          <span class="shortcut-desc">Edit speaker (active segment)</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">Space</span>
          <span class="shortcut-desc">Play/pause audio</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">Click segment</span>
          <span class="shortcut-desc">Seek & play</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">Click text</span>
          <span class="shortcut-desc">Edit text for splitting</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">‚åò+Enter</span>
          <span class="shortcut-desc">Split at newlines</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">Escape</span>
          <span class="shortcut-desc">Cancel editing</span>
        </div>
        <div class="shortcut-row">
          <span class="shortcut-key">‚Üë/‚Üì</span>
          <span class="shortcut-desc">Navigate suggestions</span>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="header">
        <h1>
          Ground Truth Creator
          <small style="font-size: 0.5em; color: #888"
            >(New Schema - Dec 2025)</small
          >
        </h1>
        <div class="controls">
          <select id="video-select">
            <option>Select Video...</option>
          </select>
          <button
            id="clusterBtn"
            onclick="clusterUnknownSegments()"
            title="Cluster segments that haven't been confirmed by a user yet (even if auto-identified)"
          >
            üî¨ Cluster Unconfirmed Segments
          </button>
          <div id="status"></div>
        </div>
      </div>

      <div id="player-section" style="display: none">
        <h3 id="video-title"></h3>

        <audio
          id="audio"
          controls
          style="width: 100%; margin-bottom: 10px"
        ></audio>
        <div id="layout"></div>
      </div>
    </div>

    <!-- Resume Auto-scroll Button -->
    <button id="resumeAutoScrollBtn" onclick="resumeAutoScroll()">
      üìç Resume Auto-scroll
    </button>

    <script type="module">
      import { init, id } from "https://esm.sh/@instantdb/core@0.13.2?bundle";

      // --- CONFIG ---
      const APP_ID = "d4802f0a-5c83-4db7-9e85-b97957881c59";
      const db = init({ appId: APP_ID });

      // --- STATE ---
      let currentVideoId = null;
      let currentData = { transcriptionRuns: [], diarizationRuns: [] };
      let selectedRunIds = new Set(); // Track which diarization runs to show

      const audio = document.getElementById("audio");
      const layout = document.getElementById("layout");
      const videoSelect = document.getElementById("video-select");
      const statusDiv = document.getElementById("status");

      // --- INITIAL LOAD ---
      db.subscribeQuery({ videos: {} }, (resp) => {
        if (resp.error) {
          console.error(resp.error);
          statusDiv.textContent = "Error loading videos.";
          return;
        }
        populateVideoSelect(resp.data.videos);
      });

      // Subscribe to all speakers for autocomplete
      db.subscribeQuery({ speakers: {} }, (resp) => {
        if (resp.error)
          return console.error("Failed to load speakers:", resp.error);
        allSpeakers = (resp.data.speakers || [])
          .map((s) => s.name)
          .filter(Boolean)
          .sort();
        console.log("Loaded", allSpeakers.length, "speakers for autocomplete");
      });

      function populateVideoSelect(videos) {
        videoSelect.innerHTML = '<option value="">Select Video...</option>';
        videos.forEach((v) => {
          const opt = document.createElement("option");
          opt.value = v.id;
          opt.textContent = v.title || v.filepath || v.id;
          videoSelect.appendChild(opt);
        });
        const savedId = localStorage.getItem("ground_truth_active_video_id");
        if (
          savedId &&
          videos.some((v) => v.id === savedId) &&
          !currentVideoId
        ) {
          videoSelect.value = savedId;
          loadVideo(savedId);
        }
      }

      videoSelect.onchange = (e) => {
        const vid = e.target.value;
        if (vid) {
          localStorage.setItem("ground_truth_active_video_id", vid);
          loadVideo(vid);
        }
      };

      function loadVideo(videoId) {
        currentVideoId = videoId;
        document.getElementById("player-section").style.display = "block";
        layout.innerHTML = '<div style="padding:20px;">Loading runs...</div>';

        // Load saved run selections for this video from localStorage
        selectedRunIds.clear();
        const savedRunIds = localStorage.getItem(
          `ground_truth_selected_runs_${videoId}`
        );
        if (savedRunIds) {
          try {
            const parsed = JSON.parse(savedRunIds);
            if (Array.isArray(parsed)) {
              parsed.forEach((id) => selectedRunIds.add(id));
            }
          } catch (e) {
            console.warn("Failed to parse saved run IDs:", e);
          }
        }

        // Updated query for new schema:
        const query = {
          videos: {
            $: { where: { id: videoId } },
            transcriptionRuns: {
              words: {},
              config: {},
            },
            diarizationRuns: {
              diarizationSegments: {
                speakerAssignments: { speaker: {} },
              },
              config: {},
            },
          },
        };

        // Track subscription updates for debugging
        let subscriptionCount = 0;
        let lastSubscriptionTime = 0;

        db.subscribeQuery(query, (resp) => {
          subscriptionCount++;
          const now = performance.now();
          const timeSinceLast = lastSubscriptionTime
            ? (now - lastSubscriptionTime).toFixed(0)
            : "N/A";
          lastSubscriptionTime = now;

          console.log(
            `üì° [Subscription #${subscriptionCount}] InstantDB fired (${timeSinceLast}ms since last)`
          );

          // Check if there are any optimistic updates that will be destroyed
          const optimisticElements =
            document.querySelectorAll(".optimistic-update");
          if (optimisticElements.length > 0) {
            console.log(
              `‚ö†Ô∏è [Subscription #${subscriptionCount}] WARNING: ${optimisticElements.length} optimistic update(s) will be destroyed by re-render!`
            );
            optimisticElements.forEach((el) => {
              const spkEl = el.querySelector(".seg-speaker");
              console.log(
                `   - Segment ${el.dataset.id?.slice(0, 8)}: "${spkEl?.textContent}"`
              );
            });
          }

          if (resp.error) return console.error(resp.error);

          // Update debug dump if it exists
          const debugDumpEl = document.getElementById("debug-dump");
          if (debugDumpEl) {
            debugDumpEl.textContent = JSON.stringify(resp.data, null, 2);
          }

          const video = resp.data.videos[0];
          if (!video) {
            layout.innerHTML =
              '<div style="padding:20px;">Video not found in DB.</div>';
            return;
          }

          // Update Player
          document.getElementById("video-title").textContent = video.title;
          let path = video.filepath || "";

          // Convert absolute filepath to relative path for server
          if (path.includes("/apps/speaker-diarization-benchmark/")) {
            path = path.split("/apps/speaker-diarization-benchmark")[1];
          } else if (path.includes("data/clips/")) {
            const match = path.match(/(data\/clips\/.+)/);
            if (match) path = "/" + match[1];
          }

          if (path && !path.startsWith("/") && !path.startsWith("http")) {
            path = "/" + path;
          }
          const currentSrc = audio.getAttribute("src");
          if (currentSrc !== path) {
            audio.src = path;

            // Restore saved playback time for this video
            const savedTime = localStorage.getItem(
              `ground_truth_playback_time_${videoId}`
            );
            if (savedTime) {
              const time = parseFloat(savedTime);
              if (!isNaN(time) && time > 0) {
                // Wait for audio to be ready before seeking
                audio.addEventListener(
                  "loadedmetadata",
                  function onLoaded() {
                    audio.currentTime = Math.min(time, audio.duration || time);
                    audio.removeEventListener("loadedmetadata", onLoaded);
                    console.log(
                      `Restored playback time to ${time.toFixed(1)}s for video ${videoId}`
                    );
                  },
                  { once: true }
                );
              }
            }
          }

          // Extract speakers from current video for autocomplete
          currentVideoSpeakers = extractSpeakersFromVideo(video);

          renderRunControls(video);
          renderLayout(video);
        });
      }

      // Extract unique speaker names from a video's diarization segments
      function extractSpeakersFromVideo(video) {
        const speakers = new Set();
        const diarRuns = video.diarizationRuns || [];
        for (const run of diarRuns) {
          for (const seg of run.diarizationSegments || []) {
            const assignments = seg.speakerAssignments || [];
            if (assignments.length > 0) {
              const mostRecent = assignments.sort(
                (a, b) =>
                  new Date(b.assigned_at || 0) - new Date(a.assigned_at || 0)
              )[0];
              const spk = mostRecent.speaker?.[0];
              if (spk?.name) speakers.add(spk.name);
            }
            const label = seg.speaker_label || "";
            if (
              label &&
              !label.match(/^SPEAKER_\d+$/) &&
              !label.match(/^SPLIT_\d+$/) &&
              label !== "UNKNOWN"
            ) {
              speakers.add(label);
            }
          }
        }
        return Array.from(speakers).sort();
      }

      function renderRunControls(video) {
        const diarRuns = video.diarizationRuns || [];
        const controlsDiv = document.querySelector(".header .controls");

        // Remove existing run checkboxes if any
        const existingContainer = document.getElementById("run-checkboxes");
        if (existingContainer) existingContainer.remove();

        const container = document.createElement("div");
        container.id = "run-checkboxes";
        container.style.display = "flex";
        container.style.gap = "10px";
        container.style.flexWrap = "wrap";
        container.style.marginLeft = "20px";
        container.style.fontSize = "0.9em";

        if (diarRuns.length === 0) {
          container.innerHTML =
            "<span style='color:#888'>No diarization runs</span>";
        } else {
          // Default selection logic - only if nothing was loaded from localStorage
          if (selectedRunIds.size === 0) {
            if (diarRuns.length <= 3) {
              diarRuns.forEach((r) => selectedRunIds.add(r.id));
            } else {
              const pref = diarRuns.find((r) => r.is_preferred) || diarRuns[0];
              if (pref) selectedRunIds.add(pref.id);
            }
            // Save initial selection
            saveSelectedRuns();
          }

          diarRuns.forEach((run) => {
            const label = document.createElement("label");
            label.style.display = "flex";
            label.style.alignItems = "center";
            label.style.cursor = "pointer";
            label.style.marginRight = "8px";
            label.style.border = "1px solid #ddd";
            label.style.padding = "2px 6px";
            label.style.borderRadius = "4px";
            label.title = `Full ID: ${run.id}\nCreated: ${run.created_at || "?"}`;

            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.value = run.id;
            cb.checked = selectedRunIds.has(run.id);
            cb.style.marginRight = "6px";

            cb.onchange = (e) => {
              if (e.target.checked) selectedRunIds.add(run.id);
              else selectedRunIds.delete(run.id);
              saveSelectedRuns();
              renderLayout(video);
            };

            const name = run.workflow || "Unknown";
            const count = run.diarizationSegments?.length || 0;
            const shortId = run.id.substring(0, 8); // Show first 8 chars of ID

            if (count === 0) {
              // Debug logging for 0 count runs
              console.warn(`Run ${run.id} (${name}) has 0 segments!`, run);
            }

            const span = document.createElement("span");
            span.innerHTML = `<b>${count}</b> segs &mdash; ${name} <span style="font-family:monospace; color:#666; font-size:0.8em">(${shortId})</span>`;

            label.appendChild(cb);
            label.appendChild(span);
            container.appendChild(label);
          });
        }

        controlsDiv.appendChild(container);
      }

      // Save selected run IDs to localStorage for the current video
      function saveSelectedRuns() {
        if (currentVideoId) {
          localStorage.setItem(
            `ground_truth_selected_runs_${currentVideoId}`,
            JSON.stringify(Array.from(selectedRunIds))
          );
        }
      }

      function renderLayout(video) {
        // Save scroll positions of existing columns before clearing
        const savedScrollPositions = {};
        document.querySelectorAll(".col-content").forEach((col, idx) => {
          const runId = col.closest(".column")?.dataset?.runId;
          if (runId) {
            savedScrollPositions[runId] = col.scrollTop;
          } else {
            savedScrollPositions[`col_${idx}`] = col.scrollTop;
          }
        });

        layout.innerHTML = "";

        // Add debug column (will be positioned at far right via CSS order: 999)
        const debugColumn = document.createElement("div");
        debugColumn.id = "debug-column";
        debugColumn.innerHTML = `
          <div class="col-header">üîç Debug Info</div>
          <pre id="debug-dump"></pre>
        `;
        layout.appendChild(debugColumn);

        // Update debug dump with current video data
        const debugDumpEl = document.getElementById("debug-dump");
        if (debugDumpEl) {
          debugDumpEl.textContent = JSON.stringify(video, null, 2);
        }

        // Re-apply cluster badges if we have cached results
        if (clusterResults) {
          requestAnimationFrame(() => {
            applyClusterBadges(clusterResults);
          });
        }
        
        try {
          const transcriptionRuns = video.transcriptionRuns || [];
          const diarizationRuns = video.diarizationRuns || [];

          // 1. Find Preferred Transcription (Baseline)
          const preferredTranscription =
            transcriptionRuns.sort(
              (a, b) => (b.words?.length || 0) - (a.words?.length || 0)
            )[0] ||
            transcriptionRuns.find((r) => r.is_preferred) ||
            transcriptionRuns[0];

          // 2. Determine which Diarization Runs to show
          let runsToShow = diarizationRuns.filter((r) =>
            selectedRunIds.has(r.id)
          );

          if (runsToShow.length === 0 && diarizationRuns.length > 0) {
            const fallback =
              diarizationRuns.find((r) => r.is_preferred) || diarizationRuns[0];
            runsToShow = [fallback];
          }

          console.log(
            `Rendering columns for runs:`,
            runsToShow.map((r) => r.id)
          );

          if (!preferredTranscription && runsToShow.length === 0) {
            layout.innerHTML =
              '<div style="padding:20px; color:#999;">No data found.</div>';
            return;
          }

          // 3. Render a column for EACH selected diarization run
          if (runsToShow.length > 0) {
            // Sort by creation date or ID to keep stable order
            runsToShow.sort((a, b) =>
              (a.created_at || "").localeCompare(b.created_at || "")
            );

            runsToShow.forEach((run) => {
              renderUnifiedTranscript(
                preferredTranscription,
                run,
                savedScrollPositions
              );
            });
          } else {
            if (preferredTranscription) {
              renderUnifiedTranscript(
                preferredTranscription,
                null,
                savedScrollPositions
              );
            }
          }
        } catch (err) {
          console.error("Render Error:", err);
          layout.innerHTML += `<div style="color:red; margin:10px;">Error rendering: ${err.message}</div>`;
        }
      }

      function renderUnifiedTranscript(
        transcriptionRun,
        diarizationRun,
        savedScrollPositions = {}
      ) {
        const col = document.createElement("div");
        col.className = "column";
        col.style.minWidth = "400px";
        if (diarizationRun?.id) {
          col.dataset.runId = diarizationRun.id;
        }

        // Header info
        const tInfo = transcriptionRun
          ? transcriptionRun.tool_version || "unknown"
          : "none";
        const tId = transcriptionRun
          ? transcriptionRun.id.substring(0, 8)
          : "N/A";

        const dInfo = diarizationRun
          ? diarizationRun.workflow || "unknown"
          : "none";
        const dId = diarizationRun ? diarizationRun.id.substring(0, 8) : "N/A";

        // Build config info panel
        const tConfig = transcriptionRun?.config?.[0] || {};
        const dConfig = diarizationRun?.config?.[0] || {};
        const segments = diarizationRun?.diarizationSegments || [];
        const words = transcriptionRun?.words || [];

        // Calculate segment stats
        const segDurations = segments
          .filter(
            (s) =>
              !s.is_invalidated && s.start_time != null && s.end_time != null
          )
          .map((s) => s.end_time - s.start_time);
        const avgDuration =
          segDurations.length > 0
            ? (
                segDurations.reduce((a, b) => a + b, 0) / segDurations.length
              ).toFixed(1)
            : 0;
        const maxDuration =
          segDurations.length > 0 ? Math.max(...segDurations).toFixed(1) : 0;
        const longSegments = segDurations.filter((d) => d > 15).length;

        // Count speaker assignments
        const withAssignment = segments.filter(
          (s) => s.speakerAssignments?.length > 0
        ).length;
        const uniqueSpeakers = new Set(segments.map((s) => s.speaker_label))
          .size;

        col.innerHTML = `
          <div class="col-header">
            <div><strong>Diarization:</strong> ${dInfo} <span style="font-family:monospace; color:#555">(${dId})</span></div>
            <div style="font-size:0.9em; color:#666; margin-top:2px;">
                <strong>Transcript:</strong> ${tInfo} <span style="font-family:monospace">(${tId})</span>
            </div>
          </div>
          <div style="background:#f5f5f5; padding:10px; margin:10px 0; border-radius:4px; font-size:0.85em;">
            <div style="display:flex; gap:15px; flex-wrap:wrap;">
              <div style="flex:1;">
                <strong>üìä Stats</strong>
                <div>Segs: ${segments.filter((s) => !s.is_invalidated).length} | Spkrs: ${uniqueSpeakers}</div>
                <div>Avg: ${avgDuration}s | Max: ${maxDuration}s</div>
              </div>
              <div style="flex:1;">
                 <strong>üîç Config</strong>
                 <div>Workflow: ${diarizationRun?.workflow || "N/A"}</div>
                 <div>Model: ${dConfig.embedding_model?.split("/").pop() || "N/A"}</div>
              </div>
            </div>
          </div>
        `;

        const colContent = document.createElement("div");
        colContent.className = "col-content";

        // Sort words by start time
        words.sort((a, b) => a.start_time - b.start_time);

        // Filter out invalidated segments and sort
        const validSegments = segments
          .filter((s) => typeof s.start_time === "number" && !s.is_invalidated)
          .sort((a, b) => a.start_time - b.start_time);

        if (validSegments.length === 0 && words.length === 0) {
          colContent.innerHTML =
            '<div style="padding:10px; color:#999;">No data to display</div>';
          col.appendChild(colContent);
          layout.appendChild(col);
          return;
        }

        // If we have diarization, use it as the primary structure
        // and attach words to each segment by time overlap
        if (validSegments.length > 0) {
          validSegments.forEach((seg) => {
            // Find words that overlap with this segment
            const segWords = words.filter((w) => {
              // Word overlaps if it starts before segment ends AND ends after segment starts
              return w.start_time < seg.end_time && w.end_time > seg.start_time;
            });

            const text = segWords.map((w) => w.text).join(" ") || "(no words)";

            renderUnifiedSegment(colContent, seg, text, diarizationRun.id);
          });
        } else {
          // No diarization - just show words grouped by transcription_segment_index
          const segmentGroups = {};
          words.forEach((w) => {
            const idx = w.transcription_segment_index ?? 0;
            if (!segmentGroups[idx]) segmentGroups[idx] = [];
            segmentGroups[idx].push(w);
          });

          Object.keys(segmentGroups)
            .sort((a, b) => Number(a) - Number(b))
            .forEach((idx) => {
              const groupWords = segmentGroups[idx];
              groupWords.sort((a, b) => a.start_time - b.start_time);

              const fakeSeg = {
                start_time: groupWords[0].start_time,
                end_time: groupWords[groupWords.length - 1].end_time,
                speaker_label: "UNKNOWN",
                speakerAssignments: [],
              };

              const text = groupWords.map((w) => w.text).join(" ");
              renderUnifiedSegment(colContent, fakeSeg, text, null);
            });
        }

        col.appendChild(colContent);
        layout.appendChild(col);

        // Restore scroll position after render, then scroll to active segment
        const runId = diarizationRun?.id;
        requestAnimationFrame(() => {
          // First restore saved scroll position if available
          if (runId && savedScrollPositions[runId] !== undefined) {
            colContent.scrollTop = savedScrollPositions[runId];
          }

          // Then scroll to the active segment based on current audio time
          // This ensures we're viewing the right segment after re-render
          scrollToActiveSegment(colContent);
        });
      }

      // Scroll to the segment that matches current audio time within a specific column
      function scrollToActiveSegment(colContent) {
        if (!colContent) return;

        const t = audio.currentTime;
        const segments = colContent.querySelectorAll(".segment");

        for (const seg of segments) {
          const s = parseFloat(seg.dataset.start);
          const e = parseFloat(seg.dataset.end);

          if (t >= s && t < e) {
            // Found the active segment - scroll to it
            seg.scrollIntoView({ behavior: "instant", block: "center" });
            seg.classList.add("active");
            return;
          }
        }
      }

      function renderUnifiedSegment(container, seg, text, runId) {
        const item = document.createElement("div");
        item.className = "segment";
        item.dataset.start = seg.start_time;
        item.dataset.end = seg.end_time;
        if (seg.id) item.dataset.id = seg.id;
        item.dataset.type = "unified";
        if (runId) item.dataset.runId = runId;
        if (seg.speaker_label) item.dataset.speakerLabel = seg.speaker_label;

        // Get speaker name from assignments (most recent) or fall back to label
        let speakerName = seg.speaker_label || "UNKNOWN";
        let speakerId = null;
        let assignmentSource = null;

        const assignments = seg.speakerAssignments || [];
        if (assignments.length > 0) {
          const sorted = [...assignments].sort(
            (a, b) => new Date(b.assigned_at) - new Date(a.assigned_at)
          );
          const mostRecent = sorted[0];
          assignmentSource = mostRecent.source;

          const speaker = mostRecent.speaker;
          if (speaker) {
            if (Array.isArray(speaker) && speaker.length > 0) {
              speakerName = speaker[0].name || speakerName;
              speakerId = speaker[0].id;
            } else if (speaker.name) {
              speakerName = speaker.name;
              speakerId = speaker.id;
            }
          }
        }

        if (speakerId) item.dataset.spkId = speakerId;

        // Source indicator
        const sourceIcon =
          assignmentSource === "user"
            ? "‚úì "
            : assignmentSource === "model"
              ? "ü§ñ "
              : "";

        // Check if speaker is still a machine label
        const isMachineLabel =
          speakerName.startsWith("SPEAKER_") || speakerName === "UNKNOWN";
        const speakerClass = isMachineLabel
          ? "seg-speaker unlabeled"
          : "seg-speaker";

        // Add quick confirm button for auto-labeled segments (has speaker_label but no user assignment)
        const hasAutoLabel = speakerName && !speakerName.startsWith("SPEAKER_") && speakerName !== "UNKNOWN" && assignmentSource !== "user";
        const quickConfirmBtn = hasAutoLabel && seg.id
          ? `<button onclick="quickConfirmSegment('${seg.id}', '${speakerName.replace(/'/g, "\\'")}', event)" 
                     style="background: #4caf50; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 0.75em; margin-left: 4px;"
                     title="Confirm this speaker">‚úì</button>`
          : "";
        
        item.innerHTML = `
                <div class="segment-header">
                    <span class="${speakerClass}">${sourceIcon}${speakerName}</span>${quickConfirmBtn}
                    <span class="timestamp">${seg.start_time.toFixed(1)}s - ${seg.end_time.toFixed(1)}s</span>
                </div>
                <div class="segment-text" title="Click to edit ‚Ä¢ Cmd+Enter to split at newlines">${text}</div>
            `;

        // Click on card (not text) = seek and play
        item.onclick = (e) => {
          if (["INPUT", "TEXTAREA"].includes(e.target.tagName)) return;
          if (e.target.classList.contains("segment-text")) return; // Let text handle its own click
          if (e.target.classList.contains("seg-speaker")) return; // Let speaker handle its own click
          e.stopPropagation();

          // Resume auto-scroll when user clicks on a segment
          resumeAutoScroll();

          // Use dataset.start which is always set, fallback to seg.start_time
          const startTime =
            parseFloat(item.dataset.start) || seg.start_time || 0;
          console.log(
            `Seeking to ${startTime}s (from dataset: ${item.dataset.start})`
          );
          audio.currentTime = startTime;
          audio.play().catch((err) => console.log("Autoplay blocked:", err));
        };

        // Click on text = edit mode (for splitting)
        const textEl = item.querySelector(".segment-text");
        if (textEl) {
          textEl.onclick = (e) => {
            e.stopPropagation();
            editSplit(item);
          };
        }

        // Click on speaker = edit speaker
        const spkEl = item.querySelector(".seg-speaker");
        if (spkEl && seg.id) {
          spkEl.onclick = (e) => {
            e.stopPropagation();
            editSpeaker(item);
          };
        }

        // Click on timestamp = seek and play
        const timestampEl = item.querySelector(".timestamp");
        if (timestampEl) {
          timestampEl.style.cursor = "pointer";
          timestampEl.onclick = (e) => {
            e.stopPropagation();
            const startTime = parseFloat(item.dataset.start) || 0;
            console.log(`Timestamp clicked - seeking to ${startTime}s`);
            audio.currentTime = startTime;
            audio.play().catch((err) => console.log("Autoplay blocked:", err));
          };
        }

        container.appendChild(item);
      }

      // --- KEYBOARD & ACTIONS ---

      document.addEventListener("keydown", (e) => {
        const tag = e.target.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA" || e.target.isContentEditable)
          return;

        // Space: Toggle Play
        if (e.code === "Space") {
          e.preventDefault();
          audio.paused ? audio.play() : audio.pause();
          return;
        }

        // Navigation
        if (
          ["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(e.code)
        ) {
          e.preventDefault();
          navigate(e.code === "ArrowLeft" || e.code === "ArrowUp" ? -1 : 1);
          return;
        }

        // Enter: Edit Speaker (any segment type)
        if (e.code === "Enter" && !e.metaKey && !e.ctrlKey) {
          e.preventDefault();
          const active =
            document.querySelector(".segment.active") || activeSegmentEl;
          if (active) {
            editSpeaker(active);
          }
          return;
        }

        // Cmd+Enter: Split (Both)
        if ((e.metaKey || e.ctrlKey) && e.code === "Enter") {
          e.preventDefault();
          const active = document.querySelector(".segment.active");
          if (active) {
            editSplit(active);
          }
          return;
        }

        // Delete / Backspace: Delete Segment (Diarization)
        // Use Ctrl+Delete or Cmd+Backspace to avoid accidental deletions?
        // User asked for "removing... incorrectly linked".
        // Let's protect it slightly with Cmd/Ctrl or just confirm?
        // Let's try Delete key directly, but maybe with confirm?
        // "Backspace" is dangerous for text editing (handled by input check above).
        // "Delete" (Fn+Backspace on Mac) is safer.
        // Let's support both but with confirm.
        if (
          ["Delete", "Backspace"].includes(e.code) &&
          !e.target.isContentEditable
        ) {
          // Double check input focus again just in case
          if (["INPUT", "TEXTAREA"].includes(document.activeElement.tagName))
            return;

          const active = document.querySelector(".segment.active");
          if (active && active.dataset.type === "diarization") {
            e.preventDefault();
            if (
              confirm(
                "Are you sure you want to DELETE this segment and its embedding?"
              )
            ) {
              deleteSegment(active);
            }
          }
        }
      });

      async function deleteSegment(segEl) {
        try {
          const res = await fetch("/delete_segment", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              segment_id: segEl.dataset.id,
            }),
          });
          if (!res.ok) throw await res.text();
          // InstantDB updates automatically
        } catch (e) {
          alert("Failed to delete: " + e);
        }
      }

      function navigate(dir) {
        const allSegs = Array.from(document.querySelectorAll(".segment"));
        if (!allSegs.length) return;

        // Sort deterministically by start time, then by runId (to group columns if times are equal), then ID
        allSegs.sort((a, b) => {
          const ta = parseFloat(a.dataset.start);
          const tb = parseFloat(b.dataset.start);
          if (ta !== tb) return ta - tb;

          // If times equal, sorting by DOM order might be safer for "visual" flow?
          // But DOM order is Column A (all rows), Column B (all rows).
          // So purely time-based sorting jumps between columns.
          // If user wants to navigate "Down", they expect the next segment in THIS column?
          // Or next chronological segment?
          // Visual "Down" usually means next in column.
          // Visual "Right" means next column?
          // User said "Up/Left... Down/Right".
          // Let's implement Time-Based for now as it's general.
          return 0;
          // Note: Sort is stable in modern JS, so DOM order preserved for equal times.
        });

        // Find ALL active segments (could be multiple if overlapping)
        // But usually only one is "active" by auto-scroll?
        // Actually auto-scroll makes multiple active if they overlap time.
        // Let's find the FIRST active one in our sorted list.
        let idx = allSegs.findIndex((el) => el.classList.contains("active"));

        // If none active, find based on current audio time
        if (idx === -1) {
          const t = audio.currentTime;
          // Find first segment starting after t? Or overlapping t?
          idx = allSegs.findIndex((el) => {
            const s = parseFloat(el.dataset.start);
            const e = parseFloat(el.dataset.end);
            return t >= s && t < e;
          });

          // If still not found (gap), find next start
          if (idx === -1) {
            idx = allSegs.findIndex((el) => parseFloat(el.dataset.start) > t);
          }

          if (idx === -1) idx = 0;
        }

        let newIdx = idx + dir;
        // Clamp
        if (newIdx < 0) newIdx = 0;
        if (newIdx >= allSegs.length) newIdx = allSegs.length - 1;

        const target = allSegs[newIdx];
        if (target) {
          console.log(
            `Navigating to ${newIdx} (Time: ${target.dataset.start})`
          );
          target.scrollIntoView({ behavior: "smooth", block: "center" });
          // We manually click to play/set active?
          // navigate() implies moving selection?
          // Or just seeking?
          // User said "Navigate to previous segment and start playback".
          audio.currentTime = parseFloat(target.dataset.start);
          audio.play();
        }
      }

      // Auto-scroll / Active Class + Save playback time
      audio.ontimeupdate = () => {
        const t = audio.currentTime;
        activeSegmentEl = null; // Reset

        // Save playback time to localStorage (throttled - only every 2 seconds)
        if (
          currentVideoId &&
          (!audio._lastSaveTime || t - audio._lastSaveTime >= 2)
        ) {
          localStorage.setItem(
            `ground_truth_playback_time_${currentVideoId}`,
            t.toString()
          );
          audio._lastSaveTime = t;
        }

        document.querySelectorAll(".segment").forEach((el) => {
          const s = parseFloat(el.dataset.start);
          const e = parseFloat(el.dataset.end);

          // Allow a small tolerance for 'active'
          if (t >= s && t < e) {
            if (!el.classList.contains("active")) {
              el.classList.add("active");
              // Only auto-scroll if enabled
              if (autoScrollEnabled) {
                el.scrollIntoView({ behavior: "smooth", block: "center" });
              }
            }
            // Track the active segment for keyboard shortcuts
            activeSegmentEl = el;
          } else {
            el.classList.remove("active");
          }
        });
      };

      // Also save on pause and before unload
      audio.onpause = () => {
        if (currentVideoId) {
          localStorage.setItem(
            `ground_truth_playback_time_${currentVideoId}`,
            audio.currentTime.toString()
          );
          console.log(
            `Saved playback time ${audio.currentTime.toFixed(1)}s on pause`
          );
        }
      };

      window.addEventListener("beforeunload", () => {
        if (currentVideoId && audio.currentTime > 0) {
          localStorage.setItem(
            `ground_truth_playback_time_${currentVideoId}`,
            audio.currentTime.toString()
          );
        }
      });

      // --- EDITING LOGIC ---

      // Track active (playing) segment for keyboard shortcuts
      let activeSegmentEl = null;
      let allSpeakers = []; // All speakers from DB
      let currentVideoSpeakers = []; // Speakers in current video

      // --- AUTO-SCROLL CONTROL ---
      let autoScrollEnabled = true;

      /**
       * Pause auto-scroll when user manually scrolls.
       * Shows the "Resume Auto-scroll" button.
       */
      function pauseAutoScroll() {
        if (autoScrollEnabled) {
          autoScrollEnabled = false;
          document.getElementById("resumeAutoScrollBtn").style.display =
            "block";
        }
      }

      /**
       * Resume auto-scroll and hide the button.
       */
      function resumeAutoScroll() {
        autoScrollEnabled = true;
        document.getElementById("resumeAutoScrollBtn").style.display = "none";
      }

      // Detect manual scroll on segment containers
      document.addEventListener(
        "wheel",
        function (e) {
          // Only pause if scrolling in the segments area
          if (e.target.closest(".col-content, .segment, #layout")) {
            pauseAutoScroll();
          }
        },
        { passive: true }
      );

      // Export resumeAutoScroll to window for onclick handler
      window.resumeAutoScroll = resumeAutoScroll;

      // Toggle shortcuts panel
      function toggleShortcuts() {
        const list = document.getElementById("shortcut-list");
        const btn = document.querySelector("#shortcuts-panel .toggle-btn");
        list.classList.toggle("expanded");
        btn.textContent = list.classList.contains("expanded") ? "‚ñ≤" : "‚ñº";
      }

      // Export toggleShortcuts to window for onclick handler
      window.toggleShortcuts = toggleShortcuts;

      // Start with shortcuts visible
      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("shortcut-list").classList.add("expanded");
      });

      // NOTE: Main keyboard handler is at line ~762
      // This second handler was causing conflicts - removed
      // All keyboard shortcuts now handled in the first handler

      function editSpeaker(segEl) {
        const spkEl = segEl.querySelector(".seg-speaker");
        if (!spkEl) return;

        // Strip any source icons from the display name
        const currentName = spkEl.textContent.replace(/^[‚úìü§ñ]\s*/, "").trim();
        const speakerLabel = segEl.dataset.speakerLabel || "";

        // Create autocomplete container
        const container = document.createElement("div");
        container.className = "speaker-autocomplete";
        container.onclick = (e) => e.stopPropagation();

        const input = document.createElement("input");
        input.type = "text";
        input.value =
          currentName === "UNKNOWN" || currentName === speakerLabel
            ? ""
            : currentName;
        input.placeholder = `Speaker name...`;

        const dropdown = document.createElement("div");
        dropdown.className = "autocomplete-dropdown";
        dropdown.style.display = "none";

        container.appendChild(input);
        container.appendChild(dropdown);

        const originalParent = spkEl.parentNode;
        originalParent.replaceChild(container, spkEl);
        audio.pause();
        input.focus();
        input.select();

        let selectedIndex = -1;

        // Build speaker suggestions
        function getSuggestions(query) {
          const q = query.toLowerCase();
          const suggestions = [];

          // Current video speakers first
          const currentMatches = currentVideoSpeakers
            .filter((s) => s.toLowerCase().includes(q))
            .sort((a, b) => {
              // Exact start match first
              const aStarts = a.toLowerCase().startsWith(q);
              const bStarts = b.toLowerCase().startsWith(q);
              if (aStarts && !bStarts) return -1;
              if (!aStarts && bStarts) return 1;
              return a.localeCompare(b);
            });

          currentMatches.forEach((s) => {
            suggestions.push({ name: s, isCurrentVideo: true });
          });

          // All speakers (excluding ones already shown)
          const otherMatches = allSpeakers
            .filter(
              (s) =>
                s.toLowerCase().includes(q) && !currentVideoSpeakers.includes(s)
            )
            .sort((a, b) => a.localeCompare(b));

          otherMatches.forEach((s) => {
            suggestions.push({ name: s, isCurrentVideo: false });
          });

          return suggestions;
        }

        function renderDropdown() {
          const suggestions = getSuggestions(input.value);
          dropdown.innerHTML = "";

          if (suggestions.length === 0) {
            dropdown.style.display = "none";
            return;
          }

          let hasCurrentVideo = false;
          let hasOther = false;

          suggestions.forEach((s, idx) => {
            // Section headers
            if (s.isCurrentVideo && !hasCurrentVideo) {
              const header = document.createElement("div");
              header.className = "autocomplete-section";
              header.textContent = "üìç This Video";
              dropdown.appendChild(header);
              hasCurrentVideo = true;
            } else if (!s.isCurrentVideo && !hasOther) {
              const header = document.createElement("div");
              header.className = "autocomplete-section";
              header.textContent = "üåê All Speakers";
              dropdown.appendChild(header);
              hasOther = true;
            }

            const item = document.createElement("div");
            item.className =
              "autocomplete-item" + (s.isCurrentVideo ? " current-video" : "");
            if (idx === selectedIndex) item.classList.add("selected");
            item.textContent = s.name;
            item.onmousedown = (e) => {
              e.preventDefault();
              input.value = s.name;
              input.blur();
            };
            dropdown.appendChild(item);
          });

          dropdown.style.display = "block";
        }

        input.oninput = () => {
          selectedIndex = -1;
          renderDropdown();
        };

        input.onfocus = () => {
          renderDropdown();
        };

        input.onkeydown = (e) => {
          const items = dropdown.querySelectorAll(".autocomplete-item");

          if (e.key === "ArrowDown") {
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
            renderDropdown();
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - 1, -1);
            renderDropdown();
          } else if (e.key === "Enter") {
            e.preventDefault();
            if (selectedIndex >= 0 && items[selectedIndex]) {
              input.value = items[selectedIndex].textContent;
            }
            input.blur();
          } else if (e.key === "Escape") {
            e.preventDefault();
            input.value = currentName;
            input.blur();
          } else if (e.key === "Tab" && items.length > 0) {
            e.preventDefault();
            const idx = selectedIndex >= 0 ? selectedIndex : 0;
            if (items[idx]) input.value = items[idx].textContent;
            input.blur();
          }
        };

        const cleanup = () => {
          const newName = input.value.trim();

          // IMPORTANT: Restore the original speaker element FIRST
          // so that createSpeakerAssignment can find it for optimistic updates
          originalParent.replaceChild(spkEl, container);

          // Now call createSpeakerAssignment - it will find the .seg-speaker element
          if (newName && newName !== currentName) {
            createSpeakerAssignment(segEl.dataset.id, newName);
          }
        };

        input.onblur = () => {
          // Small delay to allow click on dropdown
          setTimeout(cleanup, 150);
        };

        // Initial render
        renderDropdown();
      }

      // Legacy function kept for compatibility
      async function relabelSegment(segId, newName) {
        return createSpeakerAssignment(segId, newName);
      }

      function editSplit(segEl) {
        const textEl = segEl.querySelector(".segment-text");

        if (!textEl) {
          alert("No text to edit in this segment.");
          return;
        }

        const currentText = textEl.textContent;
        const segmentId = segEl.dataset.id;

        if (!segmentId) {
          alert("No segment ID found. Cannot split this segment.");
          return;
        }

        const textarea = document.createElement("textarea");
        textarea.value = currentText.trim();
        textarea.style.width = "100%";
        textarea.style.minHeight = "80px";
        textarea.style.padding = "8px";
        textarea.style.fontFamily = "inherit";
        textarea.style.fontSize = "inherit";
        textarea.style.border = "2px solid #2196f3";
        textarea.style.borderRadius = "4px";
        textarea.style.resize = "vertical";
        textarea.onclick = (e) => e.stopPropagation();

        // Add helper text
        const helper = document.createElement("div");
        helper.style.fontSize = "0.75em";
        helper.style.color = "#666";
        helper.style.marginTop = "4px";
        helper.innerHTML =
          "<kbd>Cmd+Enter</kbd> to split at newlines ‚Ä¢ <kbd>Escape</kbd> to cancel";

        const parent = textEl.parentNode;
        parent.replaceChild(textarea, textEl);
        parent.appendChild(helper);
        audio.pause();
        textarea.focus();

        const cleanup = () => {
          parent.replaceChild(textEl, textarea);
          if (helper.parentNode) helper.remove();
        };

        textarea.onkeydown = (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
            e.preventDefault();

            const lines = textarea.value
              .split("\n")
              .map((l) => l.trim())
              .filter((l) => l);

            if (lines.length > 1) {
              // Split the segment! Server will look up all the details.
              performSplit(segmentId, lines);
              cleanup();
            } else {
              // Just one line - no split needed
              console.log("Only one line, no split performed");
              cleanup();
            }
          }

          if (e.key === "Escape") {
            e.preventDefault();
            cleanup();
          }
        };

        textarea.onblur = (e) => {
          // Small delay to allow Cmd+Enter to process first
          setTimeout(() => {
            if (textarea.parentNode) cleanup();
          }, 100);
        };
      }

      /**
       * Split a diarization segment into multiple segments.
       *
       * SIMPLIFIED API - just send:
       * - segment_id: The segment to split
       * - lines: Array of text lines (one per resulting segment)
       *
       * Server looks up start_time, end_time, run_id from the segment.
       *
       * FLOW:
       * 1. User edits segment text and adds newlines
       * 2. Press Cmd+Enter to split
       * 3. Server creates SegmentSplit record (audit trail)
       * 4. Original segment marked is_invalidated=true
       * 5. New segments created with SPLIT_0, SPLIT_1, etc. labels
       * 6. UI refreshes via InstantDB subscription
       */
      async function performSplit(segmentId, lines) {
        if (!segmentId) {
          alert("No segment ID - cannot split.");
          return;
        }

        if (lines.length < 2) {
          alert(
            "Need at least 2 lines to split. Add newlines to indicate split points."
          );
          return;
        }

        try {
          const res = await fetch("/split_segment", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              segment_id: segmentId,
              lines: lines,
            }),
          });

          if (!res.ok) {
            const errText = await res.text();
            throw new Error(errText);
          }

          const result = await res.json();
          console.log("Split successful:", result);
          // InstantDB subscription will automatically update the UI
        } catch (e) {
          console.error("Split failed:", e);
          alert("Failed to split segment: " + e.message);
        }
      }

      // Toast notification system
      function showToast(message, type = "info", duration = 3000) {
        const container = document.getElementById("toast-container");
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;
        toast.textContent = message;
        container.appendChild(toast);

        setTimeout(() => {
          toast.style.animation = "slideOut 0.3s ease-out forwards";
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      // ============================================
      // CLUSTERING FUNCTIONALITY
      // ============================================

      /**
       * Global state for clustering results.
       * Maps segment IDs to their cluster assignments.
       */
      let clusterResults = null;

      /**
       * Get the currently selected diarization run ID.
       * Tries multiple sources: selectedRunIds Set, URL params, etc.
       */
      function getCurrentDiarizationRunId() {
        // First, try to get from selectedRunIds (the Set of checked runs)
        if (selectedRunIds.size > 0) {
          // Return the first selected run ID
          return Array.from(selectedRunIds)[0];
        }

        // Try to get from URL params
        const urlParams = new URLSearchParams(window.location.search);
        const runId =
          urlParams.get("run_id") || urlParams.get("diarization_run_id");
        if (runId) return runId;

        return null;
      }

      /**
       * Trigger HDBSCAN clustering for unlabeled segments in the selected diarization run.
       * Calls the /cluster endpoint and displays results with visual cluster grouping.
       */
      async function clusterUnknownSegments() {
        const btn = document.getElementById("clusterBtn");
        const originalText = btn.textContent;

        const diarizationRunId = getCurrentDiarizationRunId();

        if (!diarizationRunId) {
          showToast(
            "No diarization run selected. Please select a run first.",
            "error"
          );
          return;
        }

        btn.disabled = true;
        btn.textContent = "‚è≥ Clustering...";

        try {
          const response = await fetch("/cluster", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              diarization_run_id: diarizationRunId,
              min_cluster_size: 2,
              min_samples: 1,
            }),
          });

          const result = await response.json();

          if (!result.success) {
            throw new Error(result.error || "Clustering failed");
          }

          clusterResults = result;
          displayClusterResults(result);
          showToast(
            `Found ${result.stats.num_clusters} clusters from ${result.stats.total_embeddings} embeddings`,
            "success"
          );
        } catch (error) {
          console.error("Clustering error:", error);
          showToast("Clustering failed: " + error.message, "error");
        } finally {
          btn.disabled = false;
          btn.textContent = originalText;
        }
      }

      /**
       * Display clustering results: show stats and apply cluster badges to segments.
       * Also shows clickable representative segments for each cluster.
       */
      function displayClusterResults(result) {
        // Build cluster details with clickable representatives
        let clusterDetailsHtml = "";

        // Get segment_info from server response (contains start_time, end_time for each segment)
        const segmentInfo = result.segment_info || {};

        // Sort clusters by size (largest first)
        const sortedClusters = Object.entries(result.clusters)
          .map(([clusterId, segmentIds]) => ({
            clusterId: parseInt(clusterId),
            segmentIds,
            count: segmentIds.length,
            representative: result.representatives[clusterId],
          }))
          .sort((a, b) => b.count - a.count);

        sortedClusters.forEach((cluster) => {
          const repSegId = cluster.representative;

          // Get segment info from server response (not DOM)
          const segInfo = segmentInfo[repSegId] || {};
          const startTime = segInfo.start_time;
          const endTime = segInfo.end_time;
          const speakerLabel = segInfo.speaker_label || "UNKNOWN";

          // Try to get text from DOM if available, otherwise show speaker label
          // Note: These are UNCONFIRMED segments (no user assignment yet)
          // The speaker_label is from automatic identification, not user confirmation
          const repSegEl = document.querySelector(
            `.segment[data-id="${repSegId}"]`
          );
          const text = repSegEl
            ? repSegEl
                .querySelector(".segment-text")
                ?.textContent?.substring(0, 50) + "..."
            : `[${speakerLabel}]`;

          // Show that this is an auto-identified label, not user-confirmed
          const labelDisplay =
            speakerLabel === "UNKNOWN" ? "UNKNOWN" : `${speakerLabel} (auto)`;

          const badgeClass = `cluster-${cluster.clusterId % 6}`;

          clusterDetailsHtml += `
            <div class="cluster-detail" style="margin: 8px 0; padding: 8px; background: #f9f9f9; border-radius: 4px; border-left: 4px solid var(--cluster-color-${cluster.clusterId % 6}, #ccc);" data-cluster-id="${cluster.clusterId}">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span class="cluster-badge ${badgeClass}">Cluster ${cluster.clusterId}</span>
                <div style="display: flex; gap: 8px; align-items: center;">
                  <span style="font-size: 0.85em; color: #666;">${cluster.count} segments</span>
                  <button onclick="bulkConfirmCluster(${cluster.clusterId}, ${JSON.stringify(cluster.segmentIds).replace(/"/g, "'")}, '${speakerLabel.replace(/'/g, "\\'")}')"
                          style="background: #4caf50; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.8em;">
                    ‚úì Confirm All
                  </button>
                </div>
              </div>
              <div style="font-size: 0.8em; color: #888; margin-top: 4px;">
                Auto-label: <span style="font-style: italic;">${labelDisplay}</span>
              </div>
              ${
                startTime != null
                  ? `
                <div class="cluster-representative-link"
                     data-segment-id="${repSegId}"
                     data-start="${startTime}"
                     style="margin-top: 6px; padding: 6px; background: #fff; border: 1px solid #e0e0e0; border-radius: 4px; cursor: pointer; font-size: 0.85em;"
                     onclick="seekToSegment('${repSegId}', ${startTime})">
                  <span style="color: #2196f3;">‚ñ∂</span>
                  <span style="font-family: monospace; color: #888;">${startTime.toFixed(1)}s - ${endTime ? endTime.toFixed(1) + "s" : ""}</span>
                  <span style="color: #333; margin-left: 8px;">${text}</span>
                </div>
              `
                  : `<div style="margin-top: 6px; padding: 6px; color: #999; font-size: 0.85em;">No timing info available</div>`
              }
            </div>
          `;
        });

        // Add noise info if any
        if (result.noise.length > 0) {
          clusterDetailsHtml += `
            <div class="cluster-detail" style="margin: 8px 0; padding: 8px; background: #f5f5f5; border-radius: 4px; border-left: 4px solid #999;">
              <span class="cluster-badge cluster-noise">Noise</span>
              <span style="font-size: 0.85em; color: #666; margin-left: 8px;">${result.noise.length} segments (no clear cluster)</span>
            </div>
          `;
        }

        // Show stats panel with cluster details
        const statsHtml = `
          <div class="cluster-stats" id="cluster-stats-panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <strong>üî¨ Clustering Results</strong>
              <button onclick="document.getElementById('cluster-stats-panel').remove()"
                      style="background: none; border: none; cursor: pointer; font-size: 1.2em; color: #999;">‚úï</button>
            </div>
            <div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 12px; font-size: 0.85em;">
              ‚ÑπÔ∏è <strong>Note:</strong> These are segments without <em>user confirmation</em>.
              Some may show auto-identified speaker names (e.g., "Shane Gillis (auto)") but haven't been verified by a human yet.
              Clustering groups similar voices together to speed up labeling.
            </div>
            <div style="display: flex; gap: 20px; margin-bottom: 12px;">
              <div>üìä Unconfirmed: <strong>${result.stats.total_embeddings}</strong></div>
              <div>üéØ Clusters: <strong>${result.stats.num_clusters}</strong></div>
              <div>üîá Noise: <strong>${result.stats.noise_count}</strong></div>
            </div>
            <div style="border-top: 1px solid #ddd; padding-top: 12px;">
              <strong style="font-size: 0.9em;">Click to jump to representative segment:</strong>
              ${clusterDetailsHtml}
            </div>
          </div>
        `;

        // Insert stats before the layout
        const layoutEl = document.getElementById("layout");
        if (layoutEl) {
          // Remove old stats if present
          const oldStats = document.getElementById("cluster-stats-panel");
          if (oldStats) oldStats.remove();

          layoutEl.insertAdjacentHTML("beforebegin", statsHtml);
        }

        // Apply cluster badges to segments
        applyClusterBadges(result);
      }

      /**
       * Seek audio to a specific segment and highlight it.
       */
      function seekToSegment(segmentId, startTime) {
        console.log(`Seeking to segment ${segmentId} at ${startTime}s`);

        // Seek audio
        audio.currentTime = startTime;
        audio.play().catch((err) => console.log("Autoplay blocked:", err));

        // Find and highlight the segment
        const segEl = document.querySelector(
          `.segment[data-id="${segmentId}"]`
        );
        if (segEl) {
          // Resume auto-scroll so it follows
          resumeAutoScroll();

          // Scroll to segment
          segEl.scrollIntoView({ behavior: "smooth", block: "center" });

          // Flash highlight effect
          segEl.style.transition = "background-color 0.3s";
          segEl.style.backgroundColor = "#fff3cd";
          setTimeout(() => {
            segEl.style.backgroundColor = "";
          }, 1000);
        }
      }

      // Export seekToSegment to window for onclick handler
      window.seekToSegment = seekToSegment;

      /**
       * Bulk confirm all segments in a cluster with a speaker name.
       * Prompts user for speaker name, then calls /bulk_confirm endpoint.
       */
      async function bulkConfirmCluster(clusterId, segmentIds, suggestedName) {
        const speakerName = prompt(
          `Confirm all ${segmentIds.length} segments in Cluster ${clusterId} as:`,
          suggestedName || ""
        );
        
        if (!speakerName || !speakerName.trim()) {
          return; // User cancelled
        }
        
        const btn = event?.target;
        if (btn) {
          btn.disabled = true;
          btn.textContent = "‚è≥ Confirming...";
        }
        
        try {
          const response = await fetch("/bulk_confirm", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              segment_ids: segmentIds,
              speaker_name: speakerName.trim()
            })
          });
          
          const result = await response.json();
          
          if (!result.success) {
            throw new Error(result.error || "Bulk confirm failed");
          }
          
          showToast(
            `‚úÖ Confirmed ${result.updated_count} segments as "${speakerName}"`,
            "success"
          );
          
          // Remove the cluster from the results panel since it's now confirmed
          const clusterPanel = document.getElementById("cluster-stats-panel");
          if (clusterPanel) {
            const clusterDetail = clusterPanel.querySelector(
              `.cluster-detail:has(.cluster-badge:contains("Cluster ${clusterId}"))`
            );
            if (clusterDetail) {
              clusterDetail.style.opacity = "0.5";
              clusterDetail.innerHTML += '<div style="color: green; font-weight: bold;">‚úì Confirmed</div>';
            }
          }
          
        } catch (error) {
          console.error("Bulk confirm error:", error);
          showToast("Bulk confirm failed: " + error.message, "error");
        } finally {
          if (btn) {
            btn.disabled = false;
            btn.textContent = "‚úì Confirm All";
          }
        }
      }
      
      // Export bulkConfirmCluster to window for onclick handler
      window.bulkConfirmCluster = bulkConfirmCluster;

      /**
       * Quick confirm a single segment with its auto-identified speaker label.
       * One-click confirmation without typing.
       */
      async function quickConfirmSegment(segmentId, speakerName, event) {
        event.stopPropagation();
        
        const btn = event.target;
        btn.disabled = true;
        btn.textContent = "‚è≥";
        
        try {
          const response = await fetch("/assign_speaker", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              segment_id: segmentId,
              speaker_name: speakerName,
              source: "user",
              assigned_by: "quick_confirm"
            })
          });
          
          const result = await response.json();
          
          if (!result.success) {
            throw new Error(result.error || "Quick confirm failed");
          }
          
          // Update the UI immediately
          const segEl = document.querySelector(`.segment[data-id="${segmentId}"]`);
          if (segEl) {
            const spkEl = segEl.querySelector(".seg-speaker");
            if (spkEl) {
              spkEl.textContent = `‚úì ${speakerName}`;
              spkEl.className = "seg-speaker";
            }
            // Remove the quick confirm button
            btn.remove();
          }
          
          showToast(`‚úì Confirmed as "${speakerName}"`, "success", 2000);
          
        } catch (error) {
          console.error("Quick confirm error:", error);
          showToast("Quick confirm failed: " + error.message, "error");
          btn.disabled = false;
          btn.textContent = "‚úì";
        }
      }
      
      // Export quickConfirmSegment to window for onclick handler
      window.quickConfirmSegment = quickConfirmSegment;





      /**
       * Apply cluster badges to segment elements based on clustering results.
       * Uses segment_id to match segments in the DOM.
       */
      function applyClusterBadges(result) {
        // Create a map of segment_id -> cluster info
        const segmentToCluster = new Map();

        // Map cluster assignments (clusters is keyed by cluster ID, values are arrays of segment IDs)
        Object.entries(result.clusters).forEach(([clusterId, segmentIds]) => {
          segmentIds.forEach((segId) => {
            segmentToCluster.set(segId, {
              clusterId: parseInt(clusterId),
              isRepresentative: result.representatives[clusterId] === segId,
            });
          });
        });

        // Map noise segments
        result.noise.forEach((segId) => {
          segmentToCluster.set(segId, {
            clusterId: -1,
            isRepresentative: false,
          });
        });

        console.log(
          `Applying cluster badges to ${segmentToCluster.size} segments`
        );

        // Find all segment elements and add badges
        document.querySelectorAll(".segment[data-id]").forEach((el) => {
          const segId = el.getAttribute("data-id");
          const clusterInfo = segmentToCluster.get(segId);

          if (clusterInfo) {
            // Remove old badge if present
            const oldBadge = el.querySelector(".cluster-badge");
            if (oldBadge) oldBadge.remove();

            // Determine badge class and text
            const badgeClass =
              clusterInfo.clusterId === -1
                ? "cluster-noise"
                : `cluster-${clusterInfo.clusterId % 6}`;

            const badgeText =
              clusterInfo.clusterId === -1
                ? "noise"
                : `Cluster ${clusterInfo.clusterId}`;

            // Create and insert badge
            const badge = document.createElement("span");
            badge.className = `cluster-badge ${badgeClass}`;
            badge.textContent = badgeText;

            // Find the segment header to insert the badge
            const headerEl = el.querySelector(".segment-header");
            if (headerEl) {
              headerEl.appendChild(badge);
            }

            // Mark representatives with special styling
            if (clusterInfo.isRepresentative) {
              el.classList.add("cluster-representative");
            } else {
              el.classList.remove("cluster-representative");
            }
          }
        });
      }

      // Make clusterUnknownSegments available globally for onclick handler
      window.clusterUnknownSegments = clusterUnknownSegments;

      // ============================================
      // END CLUSTERING FUNCTIONALITY
      // ============================================

      /**
       * Create speaker assignment with optimistic updates.
       * Uses "fire and forget" pattern - InstantDB subscription handles UI updates.
       *
       * FUTURE: Create a simple abstraction around InstantDB for "cloud functions"
       * triggered by table changes (like Firebase Cloud Functions). API could be:
       *
       *   schema.speakerAssignments.onChange((payload) => { ... })
       *   schema.speakerAssignments.onAdd((payload) => { ... })
       *   schema.speakerAssignments.onRemove((payload) => { ... })
       *
       * Payloads would be strongly typed. This could act as a queue for
       * background processing (e.g., embedding extraction after speaker assignment).
       */
      async function createSpeakerAssignment(segmentId, speakerName) {
        const t0 = performance.now();
        console.log(
          `[${(performance.now() - t0).toFixed(0)}ms] üì• START: Assigning "${speakerName}" -> segment ${segmentId.slice(0, 8)}...`
        );

        // Find the segment element in the DOM
        const segEl = document.querySelector(
          `.segment[data-id="${segmentId}"]`
        );

        // Debug: Log all segments and their IDs
        const allSegments = document.querySelectorAll(".segment");
        console.log(
          `[${(performance.now() - t0).toFixed(0)}ms] üîç DEBUG: Looking for segment with data-id="${segmentId}"`
        );
        console.log(
          `[${(performance.now() - t0).toFixed(0)}ms] üîç DEBUG: Total segments in DOM: ${allSegments.length}`
        );

        // Log first few segments to see their structure
        let foundCount = 0;
        allSegments.forEach((seg, idx) => {
          if (foundCount < 5 || seg.dataset.id === segmentId) {
            console.log(
              `[${(performance.now() - t0).toFixed(0)}ms] üîç DEBUG: Segment ${idx}: id="${seg.dataset.id || "NONE"}", start=${seg.dataset.start}`
            );
            foundCount++;
          }
        });

        const spkEl = segEl?.querySelector(".seg-speaker");

        // Debug: If segment found, log its innerHTML
        if (segEl) {
          console.log(
            `[${(performance.now() - t0).toFixed(0)}ms] üîç DEBUG: Segment innerHTML:`,
            segEl.innerHTML.substring(0, 200)
          );
          console.log(
            `[${(performance.now() - t0).toFixed(0)}ms] üîç DEBUG: Children with seg-speaker class:`,
            segEl.querySelectorAll(".seg-speaker").length
          );
        }

        console.log(
          `[${(performance.now() - t0).toFixed(0)}ms] üîç Found segment element:`,
          !!segEl,
          "speaker element:",
          !!spkEl
        );

        // Store original state for rollback on error
        const originalName =
          spkEl?.textContent.replace(/^[‚úìü§ñ‚è≥]\s*/, "").trim() || "";
        const originalClass = spkEl?.className || "";

        console.log(
          `[${(performance.now() - t0).toFixed(0)}ms] üìù Original name: "${originalName}"`
        );

        // Optimistic update: immediately update the UI
        if (spkEl) {
          console.log(
            `[${(performance.now() - t0).toFixed(0)}ms] ‚è≥ OPTIMISTIC UPDATE: Setting text to "‚è≥ ${speakerName}"`
          );
          spkEl.textContent = `‚è≥ ${speakerName}`;
          spkEl.className = "seg-speaker";
          segEl.classList.add("optimistic-update");
          console.log(
            `[${(performance.now() - t0).toFixed(0)}ms] ‚úÖ OPTIMISTIC UPDATE APPLIED - UI should show ‚è≥ now`
          );
        } else {
          console.log(
            `[${(performance.now() - t0).toFixed(0)}ms] ‚ö†Ô∏è NO SPEAKER ELEMENT - cannot apply optimistic update`
          );
        }

        // Add speaker to autocomplete immediately
        if (!currentVideoSpeakers.includes(speakerName)) {
          currentVideoSpeakers.push(speakerName);
          currentVideoSpeakers.sort();
        }

        console.log(
          `[${(performance.now() - t0).toFixed(0)}ms] üöÄ FIRING fetch request to /assign_speaker`
        );

        // Fire the request - don't block on response
        // InstantDB subscription will update the UI when data changes
        fetch("/assign_speaker", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            segment_id: segmentId,
            speaker_name: speakerName,
            source: "user",
            assigned_by: "ground_truth_ui",
          }),
        })
          .then((res) => {
            const elapsed = (performance.now() - t0).toFixed(0);
            console.log(
              `[${elapsed}ms] üì® Server response received, status: ${res.status}`
            );
            if (!res.ok) {
              return res.text().then((err) => {
                throw new Error(err);
              });
            }
            console.log(
              `[${elapsed}ms] ‚úÖ Server confirmed assignment SUCCESS`
            );
            // Update to confirmed state - but only if we still have the optimistic update
            const currentSpkEl = document.querySelector(
              `.segment[data-id="${segmentId}"] .seg-speaker`
            );
            if (currentSpkEl && currentSpkEl.textContent.includes("‚è≥")) {
              console.log(`[${elapsed}ms] üîÑ Updating from ‚è≥ to ‚úì`);
              currentSpkEl.textContent = `‚úì ${speakerName}`;
              currentSpkEl
                .closest(".segment")
                ?.classList.remove("optimistic-update");
            } else {
              console.log(
                `[${elapsed}ms] ‚ÑπÔ∏è Element already updated (probably by InstantDB subscription)`
              );
            }
          })
          .catch((e) => {
            const elapsed = (performance.now() - t0).toFixed(0);
            console.error(`[${elapsed}ms] ‚ùå Assignment FAILED:`, e);
            // Rollback on error
            const currentSpkEl = document.querySelector(
              `.segment[data-id="${segmentId}"] .seg-speaker`
            );
            if (currentSpkEl) {
              currentSpkEl.textContent = originalName;
              currentSpkEl.className = originalClass;
              currentSpkEl
                .closest(".segment")
                ?.classList.remove("optimistic-update");
            }
            showToast(`Failed: ${e.message || e}`, "error", 5000);
          });

        // Return immediately - don't wait for server
        console.log(
          `[${(performance.now() - t0).toFixed(0)}ms] üèÅ Function returning (fetch is async)`
        );
      }
    </script>
  </body>
</html>
