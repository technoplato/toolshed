<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>docker stack is my new favorite way to deploy to a VPS - Transcript</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #f9f9f9;
        }
        header {
            background: #fff;
            padding: 1rem;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
        }
        h1 { margin: 0; font-size: 1.2rem; }
        
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .video-container {
            flex: 1;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .transcript-container {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            background: #fff;
            border-left: 1px solid #ddd;
            position: relative;
        }
        
        .segment {
            margin-bottom: 1.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .segment:hover {
            background: #f0f0f0;
        }
        
        .segment.active {
            background: #e6f7ff;
            border-left: 4px solid #1890ff;
        }
        
        .timestamp {
            font-weight: bold;
            color: #1890ff;
            margin-right: 0.5rem;
            font-size: 0.9rem;
        }
        
        .text {
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .video-container {
                flex: none;
                height: 300px;
            }
        }
    </style>
</head>
<body>

<header>
    <h1>docker stack is my new favorite way to deploy to a VPS</h1>
</header>

<div class="container">
    <div class="video-container">
        <div id="player"></div>
    </div>
    <div class="transcript-container" id="transcript"></div>
</div>

<script>
    const VIDEO_ID = "fuZoxuBiL9o";
    const SEGMENTS = [{"start": 0.0, "end": 6.16, "text": "For the past few months now, I've been using a VPS when it comes to deploying my applications."}, {"start": 6.16, "end": 11.36, "text": "Initially, I achieved this by using Docker Compose, defining my entire application stack inside"}, {"start": 11.36, "end": 16.24, "text": "of a Docker Compose Yamal file, similar to what I showed in my previous video on setting up"}, {"start": 16.24, "end": 22.48, "text": "a production ready VPS. For the most part, this has been working well. However, there have been"}, {"start": 22.48, "end": 27.76, "text": "a couple of things that I've found to be a little unintuitive. One of these things is when it comes"}, {"start": 27.76, "end": 33.28, "text": "to redeploying my service stack, which I've been doing by manually ssaching into my VPS and"}, {"start": 33.28, "end": 38.8, "text": "running the Docker Compose up command. Whilst I've managed to make this work, it's not exactly the"}, {"start": 38.8, "end": 43.6, "text": "best developer experience, especially when compared to the experience of using other platforms,"}, {"start": 43.6, "end": 50.72, "text": "such as Versel, Netlify or Railway.app. Not only is this a bad developer experience, but because"}, {"start": 50.72, "end": 56.08, "text": "of the way that Docker Compose works, it also comes with some undesired side effects. The most"}, {"start": 56.08, "end": 60.88, "text": "major of these is that when you go to redeploy your application stack using the Docker Compose"}, {"start": 60.88, "end": 67.2, "text": "up command, it does so in a way that can cause downtime. This is because when Docker Compose redeploys,"}, {"start": 67.2, "end": 73.2, "text": "it begins by shutting down your already running services before attempting to deploy the upgraded ones."}, {"start": 73.2, "end": 78.24, "text": "But if there's a problem with your new application code or configuration, then these services"}, {"start": 78.24, "end": 83.6, "text": "won't be able to start back up, which will cause you to have an outage. Additionally, by needing to"}, {"start": 83.6, "end": 89.28, "text": "ssh in and copy over the Compose.yaml in order to redeploy, I find this prevents me from being able"}, {"start": 89.28, "end": 95.12, "text": "to ship fast due to the fact that it's a manual process in order to perform upgrades. Instead,"}, {"start": 95.12, "end": 99.68, "text": "I'd much rather have a solution that allowed me to easily ship remotely through either my local"}, {"start": 99.68, "end": 105.84, "text": "machine or via CICD. Similar to what those other platforms I mentioned earlier provide. However,"}, {"start": 105.84, "end": 110.48, "text": "rather than throwing in the towel and using one of these or pivoting to an entirely different"}, {"start": 110.48, "end": 116.48, "text": "solution such as Coolify, I instead decided to do some research and look for some other solutions."}, {"start": 116.48, "end": 122.0, "text": "And I ended up finding one. One, that not only solves my issues with Docker Compose,"}, {"start": 122.0, "end": 128.24, "text": "but also allows me to use the same Docker Compose file I already have set up. That solution is"}, {"start": 128.24, "end": 134.56, "text": "Docker Stack, which has quickly become my favorite way to deploy to a VPS. The way Docker Stack"}, {"start": 134.56, "end": 139.92, "text": "works is that it allows you to deploy your Docker Compose files on a node that has Docker Swarm Mode"}, {"start": 139.92, "end": 144.8, "text": "enabled, which is much better suited for production services compared to Docker Compose."}, {"start": 144.8, "end": 148.96, "text": "This is because it has support for a number of different features that I think are important when"}, {"start": 148.96, "end": 154.56, "text": "it comes to running a production service, such as blue green deployments, rolling releases,"}, {"start": 154.56, "end": 160.48, "text": "secure secrets, service rollbacks, and even clustering. Not only this, but when combined with Docker"}, {"start": 160.48, "end": 166.48, "text": "context, I'm able to remotely manage and deploy multiple VPS instances from my own workstation,"}, {"start": 166.48, "end": 171.44, "text": "all in a secure and fast way. For example, let's say I want to make a change to my"}, {"start": 171.44, "end": 177.28, "text": "guest book web application service stack by adding in a Valky instance. This service is running"}, {"start": 177.28, "end": 183.2, "text": "on a VPS and is deployed via Docker Stack. In order to do so, all I need to do is open up my"}, {"start": 183.2, "end": 188.88, "text": "Docker Compose YAML file and add in the following lines to add the Valky service. Then in order to"}, {"start": 188.88, "end": 193.84, "text": "deploy this, I can run the Docker Stack Deploy command, passing in the Docker Compose file that I"}, {"start": 193.84, "end": 199.2, "text": "want to use and the name of my stack, which in this case is called \"guess book\". Then once it's"}, {"start": 199.2, "end": 204.0, "text": "finished, I can use the following command to check the running services of this guest book stack,"}, {"start": 204.0, "end": 209.52, "text": "which I can see now has Valky up and running. Order this deployed remotely on my VPS from my"}, {"start": 209.52, "end": 214.64, "text": "local machine. In addition to this, I'm also able to manage and monitor my application from my"}, {"start": 214.64, "end": 220.48, "text": "local machine as well, such as being able to view the services logs or add secrets securely."}, {"start": 220.48, "end": 225.2, "text": "As well as this, I've also managed to set up Docker Stack to work with my CI/CD pipeline"}, {"start": 225.2, "end": 230.24, "text": "using GitHub actions, meaning whenever I push a code change to the main branch of my repo,"}, {"start": 230.24, "end": 236.08, "text": "it'll automatically deploy my entire stack. So yeah, it's a much bigger improvement compared to"}, {"start": 236.08, "end": 241.44, "text": "using Docker Compose when it comes to working on a VPS. But you may be wondering how difficult"}, {"start": 241.44, "end": 247.04, "text": "is it to get set up? Well, fortunately, it's actually pretty simple. In fact, I'm going to walk you"}, {"start": 247.04, "end": 251.6, "text": "through the steps of getting it set up on a VPS from scratch. Before showing you some of the ways"}, {"start": 251.6, "end": 257.12, "text": "you can use it. To go along with this video, I've created a simple web application using Go."}, {"start": 257.12, "end": 262.72, "text": "That we're going to deploy. This app is a simple visitor guest book that tracks the number of visits"}, {"start": 262.72, "end": 267.76, "text": "to the web page and presents that information to the user, as well as a motivational quote."}, {"start": 267.76, "end": 272.8, "text": "The code for this app is available on GitHub, which you can easily pull down yourself."}, {"start": 272.8, "end": 277.52, "text": "There's a link in the description down below. If we go ahead and open up this code, you can see that"}, {"start": 277.52, "end": 283.28, "text": "there's already a Docker file inside, as well as a Docker Compose.yaml. If we open up this file,"}, {"start": 283.28, "end": 289.04, "text": "we can see that we've defined two distinct services inside the web application and a postgres"}, {"start": 289.04, "end": 294.16, "text": "database. In addition to having the Docker file and Docker Compose already defined, the application"}, {"start": 294.16, "end": 299.44, "text": "also has a GitHub action setup as well. Currently, this performs two different automations,"}, {"start": 299.44, "end": 305.04, "text": "the first of which is running the automated tests, which, if they pass, moves on to the second step,"}, {"start": 305.04, "end": 310.16, "text": "which is building and pushing a new Docker image of the application to the GitHub container registry."}, {"start": 310.16, "end": 314.64, "text": "The interesting thing to note here is that the Docker image itself is tagged with both latest"}, {"start": 314.64, "end": 319.52, "text": "and the same commit hash that is found at the repo at the time the image is built. This makes it"}, {"start": 319.52, "end": 324.8, "text": "incredibly easy to correlate the Docker image with the code that it was built from. This is going to"}, {"start": 324.8, "end": 328.88, "text": "be important later on when it comes to automated deployments. Now that we know what the"}, {"start": 328.88, "end": 333.2, "text": "application looks like, let's go about getting it deployed. In order to do that, we're going to"}, {"start": 333.2, "end": 338.64, "text": "need a VPS instance to deploy the application on. Fortunately, that's where the sponsor of today's"}, {"start": 338.64, "end": 344.32, "text": "video comes in. Hostinger, who have not only provided me with a VPS instance to use throughout"}, {"start": 344.32, "end": 349.68, "text": "this video, but they also have a Black Friday sale going on until the 15th of December,"}, {"start": 349.68, "end": 356.64, "text": "meaning you can pick up a long term VPS for an incredibly low price. Up to 67% off. In my case,"}, {"start": 356.64, "end": 363.52, "text": "I have the KVM2 instance, which not only boasts to VCPUs and a comfy 8GB of RAM,"}, {"start": 363.52, "end": 370.0, "text": "but it also includes a hundred gigabytes of SSD storage and a huge 8TB a month of bandwidth,"}, {"start": 370.0, "end": 376.0, "text": "which would set you back over $1,000 if you are using something like Versel. You can pick up a KVM2"}, {"start": 376.0, "end": 381.6, "text": "instance yourself for only $599 a month when you purchase a 24 month term. Or if you like to go"}, {"start": 381.6, "end": 387.6, "text": "a little larger, you can put my instance to shame and get yourself a big daddy KVM8, which boasts"}, {"start": 387.6, "end": 395.28, "text": "a massive 8VCPUs and 32GB of RAM, all for just $1999 a month on a 24 month term. Additionally,"}, {"start": 395.28, "end": 400.08, "text": "if you use my coupon code \"Dreams of Code\", you'll also receive an additional discount on any of"}, {"start": 400.08, "end": 405.28, "text": "these instances, which is incredibly good value. If that wasn't enough, however, hosting"}, {"start": 405.28, "end": 410.8, "text": "out or also throwing in some premium features as well for Black Friday, including free real-time"}, {"start": 410.8, "end": 417.04, "text": "snapshots of your VPS and free automatic weekly backups, making it incredibly easy for you to recover"}, {"start": 417.04, "end": 423.12, "text": "your instance in case something goes wrong. So to get your own VPS instance, visit hostinga.com"}, {"start": 423.12, "end": 428.08, "text": "forward slash dreams of code and use my coupon code \"Dreams of Code\" to get that additional"}, {"start": 428.08, "end": 433.12, "text": "discount. A big thank you to Hostinger for sponsoring this video. With our VPS in hand,"}, {"start": 433.12, "end": 437.76, "text": "let's go about setting it up in order for us to be able to deploy our Docker stack remotely."}, {"start": 437.76, "end": 441.92, "text": "To begin, you'll want to make sure that you're using the same operating system that I am."}, {"start": 441.92, "end": 446.8, "text": "You've been to 24.04. Then you'll want to go through the additional steps of securing your"}, {"start": 446.8, "end": 452.72, "text": "root user by adding in a strong password and setting up your SSH public key. Next, if you have a"}, {"start": 452.72, "end": 458.8, "text": "spare domain name lying around, then you may want to add a DNS A record to your VPS. If not,"}, {"start": 458.8, "end": 463.68, "text": "then you can buy a pretty cheap one from Hostinger if you like. Myself, I actually bought the"}, {"start": 463.68, "end": 469.52, "text": "Zemful site domain to use for this video for only a single dollar. Either way, once your VPS is"}, {"start": 469.52, "end": 475.68, "text": "set up with your optional A record pointing to it, go ahead and SSH in as your root user. One"}, {"start": 475.68, "end": 480.24, "text": "thing to note is if you're going to use this VPS as a production machine, then I would recommend"}, {"start": 480.24, "end": 485.92, "text": "going through the same steps I mentioned in my previous video on setting up a production ready VPS,"}, {"start": 485.92, "end": 491.52, "text": "such as adding in a user account, hardening SSH and enabling a firewall. For this video,"}, {"start": 491.52, "end": 496.08, "text": "I'm going to skip all that just so we can get into the good stuff. However, if you don't feel like"}, {"start": 496.08, "end": 501.12, "text": "watching another video in addition to this one, then I've created a step-by-step guide on the steps"}, {"start": 501.12, "end": 506.16, "text": "I would normally take, which you can find a link to in the description down below. For this video,"}, {"start": 506.16, "end": 511.44, "text": "however, now that we're logged in, the next thing we want to do is install the Docker Engine. This"}, {"start": 511.44, "end": 516.32, "text": "is pretty easy to do so. All we need to do is head on over to the Docker website and copy and"}, {"start": 516.32, "end": 521.12, "text": "paste the following two commands into our terminal. The first of these is used to add Docker into"}, {"start": 521.12, "end": 526.88, "text": "the app sources. And the second one is used to install the Docker Engine. You'll notice that in"}, {"start": 526.88, "end": 532.32, "text": "the second command, I'm ignoring both the build X and compose plugins. This is because we're not"}, {"start": 532.32, "end": 537.76, "text": "going to need them. So I'm reducing the amount of bloat installed on my system. Once Docker is installed,"}, {"start": 537.76, "end": 542.48, "text": "we can check that it's working by running the following Docker PS command, which shows us that we're"}, {"start": 542.48, "end": 548.4, "text": "good to go. With our VPS setup, let's go ahead and now exit out of SSH. As we're going to deploy our"}, {"start": 548.4, "end": 553.2, "text": "application remotely, then in order to do so, we first need to change our Docker host to be that"}, {"start": 553.2, "end": 559.68, "text": "of the VPS, which we can do a couple of different ways. The first and easiest way is to just set the"}, {"start": 559.68, "end": 565.52, "text": "Docker host environment variable, pointing it to the endpoint of our VPS. Whilst this approach works,"}, {"start": 565.52, "end": 571.04, "text": "instead I prefer to use the Docker context command, which works in a similar way, but allows you to"}, {"start": 571.04, "end": 576.24, "text": "store and manage multiple different Docker hosts, making it easy to switch between them when you"}, {"start": 576.24, "end": 581.84, "text": "have multiple machines. To create a new Docker context, we can use the following Docker context"}, {"start": 581.84, "end": 586.8, "text": "create command, passing in the name we want to give it. Then we can define the Docker endpoint by"}, {"start": 586.8, "end": 592.4, "text": "using the dash dash Docker flag. As for the value we want to use here, I'm going to define this as"}, {"start": 592.4, "end": 598.72, "text": "follows, which sets my host to that of an SSH endpoint. Here is how I have my SSH endpoints set up for"}, {"start": 598.72, "end": 605.12, "text": "my own context. You can see we're specifying the SSH protocol with the SSH colon slash slash,"}, {"start": 605.12, "end": 611.04, "text": "as well as the username of my user, which is root and the hostname of my VPS. If you don't have a"}, {"start": 611.04, "end": 616.96, "text": "domain name setup, then you can just use the VPS's IP here instead. Now if I execute this command, my"}, {"start": 616.96, "end": 622.24, "text": "Docker context should be created. The last thing to do is to make use of it by using the Docker context"}, {"start": 622.24, "end": 627.76, "text": "use command, passing in the name of the context we just created. Now whenever we perform a Docker"}, {"start": 627.76, "end": 632.0, "text": "command, instead of this taking place on our local machine, it will instead take place on the"}, {"start": 632.0, "end": 637.84, "text": "Docker instance of our VPS, allowing us to configure it remotely. With our context defined, we're now"}, {"start": 637.84, "end": 643.6, "text": "ready to set up our node to use Docker stack. In order to do so, we first need to enable Docker"}, {"start": 643.6, "end": 649.84, "text": "Swarm mode on our VPS, which we can do using the following Docker Swarm in its command. Upon running"}, {"start": 649.84, "end": 654.72, "text": "this command, you should then receive a token that will allow you to connect other VPS instances"}, {"start": 654.72, "end": 660.56, "text": "to this machine in order to form a Docker Swarm cluster. Whilst this is really cool and something"}, {"start": 660.56, "end": 665.52, "text": "will take a look at another time, we're not going to do that in this video. So you can safely ignore"}, {"start": 665.52, "end": 670.48, "text": "this token or just save it somewhere else if you want to. But don't worry too much about losing it,"}, {"start": 670.48, "end": 675.68, "text": "as you can easily obtain this token again if you need. With Swarm mode enabled, we can now deploy"}, {"start": 675.68, "end": 681.76, "text": "our application using the Docker stack deploy command, passing in the path to our Docker compose.yaml"}, {"start": 681.76, "end": 687.6, "text": "using the dash c flag. The last argument to this command is to name the stack, which in my case,"}, {"start": 687.6, "end": 692.56, "text": "I'm going to call Zemful stats. Now when I go and execute this command, we should see some output"}, {"start": 692.56, "end": 697.92, "text": "letting us know that the stack is being deployed. And once it's completed, if I open up a browser window"}, {"start": 697.92, "end": 703.36, "text": "and head on over to my domain name of Zemful.site, I can see that my app is now deployed."}, {"start": 703.36, "end": 708.24, "text": "Additionally, this remote deployment also works when it comes to private images, like the one that I"}, {"start": 708.24, "end": 713.28, "text": "have here. If I go ahead and change my compose.yaml file to make use of this private image,"}, {"start": 713.28, "end": 718.24, "text": "followed by running the Docker stack deploy command, we can see that it's deployed successfully."}, {"start": 718.24, "end": 723.12, "text": "However, there is the following warning message that we receive, which is only really an issue"}, {"start": 723.12, "end": 728.32, "text": "if you're running a Docker Swarm cluster, which in this case we're not. However, to resolve this,"}, {"start": 728.32, "end": 733.76, "text": "you just need to use the dash dash with registry auth flag with the Docker stack deploy command."}, {"start": 733.76, "end": 738.24, "text": "With that, the application is now up and running and we didn't even need to copy anything over"}, {"start": 738.24, "end": 744.64, "text": "onto our VPS. Now, to be fair, you can actually use both Docker context and Docker host to deploy"}, {"start": 744.64, "end": 750.88, "text": "Docker compose remotely as well. In fact, this is what I did initially once I discovered it."}, {"start": 750.88, "end": 755.6, "text": "However, when doing so, I kept running into an issue that would cause my deployments to fail"}, {"start": 755.6, "end": 761.36, "text": "whenever I ran Docker compose up. This was because of how Docker compose manages secrets,"}, {"start": 761.36, "end": 766.56, "text": "which is that they need to be available on the host system in a file. Whilst this in itself"}, {"start": 766.56, "end": 771.6, "text": "wasn't too difficult to set up, the issue that I had was related to defining the file inside"}, {"start": 771.6, "end": 777.44, "text": "of the compose.yaml. Initially, I used a relative path, which caused problems when running the"}, {"start": 777.44, "end": 782.72, "text": "commands remotely, as it would instead resolve to my local machines path instead of the local path"}, {"start": 782.72, "end": 788.56, "text": "on the remote. Therefore, I needed to instead use the absolute path to the secret file as it related"}, {"start": 788.56, "end": 794.24, "text": "to my host. But this meant I couldn't use Docker compose locally. Additionally, there was no"}, {"start": 794.24, "end": 799.76, "text": "easy way to manage the file on the machine without resorting to SSH. And having this secret stored"}, {"start": 799.76, "end": 805.52, "text": "in plaintext on the machine felt bad from a security perspective, and not very production ready."}, {"start": 805.52, "end": 810.32, "text": "All of these issues were actually the main reason I started looking into Docker Stack and Docker"}, {"start": 810.32, "end": 816.0, "text": "Swarm, as they have a much better approach when it comes to managing secrets. The Docker secret"}, {"start": 816.0, "end": 820.88, "text": "command, this command will allow us to create the secret inside of our Docker host in a way that's"}, {"start": 820.88, "end": 826.56, "text": "both encrypted at rest and encrypted during transit. To show this in action, let's quickly open up"}, {"start": 826.56, "end": 832.48, "text": "the Docker compose YAML file and scroll down to where our database is defined. Here you can see"}, {"start": 832.48, "end": 837.52, "text": "I've been kind of naughty. As I've set the database password in both the web application and my"}, {"start": 837.52, "end": 842.96, "text": "database service as an environment variable, shame on me. Let's go ahead and change this to instead"}, {"start": 842.96, "end": 849.92, "text": "use a Docker secret. To do so, let's first create a new secret using the Docker secret create command."}, {"start": 849.92, "end": 854.64, "text": "The first argument of this command is the name of the secret that we want to create, which in my"}, {"start": 854.64, "end": 861.04, "text": "case is going to be DB-password. Then we need to specify the actual secrets value itself."}, {"start": 861.04, "end": 866.16, "text": "As I mentioned before, Docker secret is very secure, so we can't just enter in the value of the"}, {"start": 866.16, "end": 871.6, "text": "secret that we want to create. Instead, we need to either load this in from a file or load this"}, {"start": 871.6, "end": 878.16, "text": "in through the standard input using just a dash. To add a secret via SDD in, you can use something"}, {"start": 878.16, "end": 883.6, "text": "such as the printf command when it comes to macOS or Linux, piping this into the Docker secret"}, {"start": 883.6, "end": 888.96, "text": "command as follows. When I go ahead and execute this command, it will then return the ID of the"}, {"start": 888.96, "end": 894.96, "text": "created secrets, which we can also view if we run the Docker secret LS command. One thing to note"}, {"start": 894.96, "end": 901.36, "text": "is that this secret is now secret. There's no way for us to retrieve this from Docker. For example,"}, {"start": 901.36, "end": 906.08, "text": "if I run the Docker secret inspect command, you can see it gives us a bunch of information about"}, {"start": 906.08, "end": 911.28, "text": "the secrets, but not the actual secret value itself. This is a good thing when it comes to security,"}, {"start": 911.28, "end": 915.76, "text": "but you'll want to make sure that you're securely keeping the secret somewhere else as well."}, {"start": 915.76, "end": 920.64, "text": "With our secret deployed, we can now use it similar to how we would with Docker compose."}, {"start": 920.64, "end": 926.08, "text": "However, rather than setting the secret as a file, instead we define it as external."}, {"start": 926.08, "end": 930.96, "text": "Then in order to use this secret, it's pretty much the same as if we were using Docker compose,"}, {"start": 930.96, "end": 935.6, "text": "adding it to the relevant services that need access to it, and then setting it in the associated"}, {"start": 935.6, "end": 940.88, "text": "environment variables. When it comes to the database, this is the postgres password file environment"}, {"start": 940.88, "end": 948.08, "text": "variable, which needs to be set to /run/secrets/db-password. Then when it comes to my web application,"}, {"start": 948.08, "end": 952.8, "text": "I've created the same environment variable that we can use, which will load the secret from this"}, {"start": 952.8, "end": 958.24, "text": "file. Now, when I go to run this code, we can see that our database redeploys, and our application"}, {"start": 958.24, "end": 965.44, "text": "is up and running. Sort of. Actually, it's not. The database itself is working fine, but if I"}, {"start": 965.44, "end": 970.8, "text": "go ahead and run Docker PS, you can see that the new version of the web application is actually failing."}, {"start": 970.8, "end": 975.28, "text": "This is because I'm accidentally using an old image version that doesn't have the database"}, {"start": 975.28, "end": 980.88, "text": "password file environment variable set up, so it's unable to connect to the database and exiting"}, {"start": 980.88, "end": 985.92, "text": "early. However, you'll notice that if I open up a web browser and head on over to my application,"}, {"start": 985.92, "end": 991.2, "text": "it's still running. This is because Docker Stack has support for rolling releases,"}, {"start": 991.2, "end": 995.36, "text": "which means it's still running the old configuration on my application that works,"}, {"start": 995.36, "end": 1000.4, "text": "whilst it tries to spin up a new instance in order to switch over the traffic. It basically acts"}, {"start": 1000.4, "end": 1006.24, "text": "as a very simple blue green deployment, but it's out of the box. This behavior is configured using"}, {"start": 1006.24, "end": 1012.08, "text": "the following three lines, setting the start-first value of the deployment upgrade order configuration."}, {"start": 1012.08, "end": 1016.96, "text": "Personally, I think this is a great option to enable, as it allows you to have rolling releases"}, {"start": 1016.96, "end": 1022.48, "text": "when it comes to upgrading your production ready services, which is especially important if you"}, {"start": 1022.48, "end": 1028.16, "text": "have automated deployments. Let's go ahead and quickly fix this deployment by changing the image tag"}, {"start": 1028.16, "end": 1033.6, "text": "to one that supports the DB password file environment variable. Then I'm able to redeploy it using"}, {"start": 1033.6, "end": 1038.24, "text": "the Docker Stack Deploy command. Now when I go ahead and check this service, we can see that it's"}, {"start": 1038.24, "end": 1043.52, "text": "running successfully. One thing to note is that whilst this start-first configuration is available"}, {"start": 1043.52, "end": 1048.56, "text": "in the Docker Compose specification, it doesn't actually work when you use it with Docker Compose,"}, {"start": 1048.56, "end": 1054.32, "text": "or at least it didn't when I tried it. This is because both the Docker Compose specification and"}, {"start": 1054.32, "end": 1059.6, "text": "Docker Stack specification are shared, which means there are documented configuration options that"}, {"start": 1059.6, "end": 1065.36, "text": "either one or the other don't support. For example, Docker Stack when it comes to the build configuration,"}, {"start": 1065.36, "end": 1070.64, "text": "and Docker Compose with the start-first update ordering. In fact, another feature that Docker"}, {"start": 1070.64, "end": 1076.4, "text": "Compose doesn't have support for is built in load balancing, which both Docker Stack and Docker"}, {"start": 1076.4, "end": 1082.24, "text": "Swarm do. To show this in action, let me first scale up the web application to three replicas,"}, {"start": 1082.24, "end": 1087.52, "text": "using the Docker Service Scale command. Next, if I go ahead and tail the logs using the following"}, {"start": 1087.52, "end": 1093.04, "text": "Docker Service Logs command using the Dash F flag, you can see that the built-in load balancer is"}, {"start": 1093.04, "end": 1099.04, "text": "distributing these requests against each replica in a round robin way. Whilst you are able to scale"}, {"start": 1099.04, "end": 1103.76, "text": "up replicas when it comes to Docker Compose, you're only able to bind a single instance on a"}, {"start": 1103.76, "end": 1108.96, "text": "given port. This means in order to effectively use load balancing, you need to use an external"}, {"start": 1108.96, "end": 1115.28, "text": "proxy such as traffic or nginx. Now, to be fair, when it comes to my own production services,"}, {"start": 1115.28, "end": 1120.24, "text": "I actually still make use of traffic in order to perform load balancing, mainly because it provides"}, {"start": 1120.24, "end": 1126.64, "text": "the ability for HDDPS and does a better job at forwarding client IPs. This is typically what my"}, {"start": 1126.64, "end": 1132.0, "text": "traffic implementation looks like, which sets up load balancing from my web service and automatically"}, {"start": 1132.0, "end": 1138.24, "text": "generates certs as well. As I just mentioned, there is one issue that I found when using Docker Swarm."}, {"start": 1138.24, "end": 1142.88, "text": "Because of the way that Docker Compose Handlers load balancing, it prevents the original client IP"}, {"start": 1142.88, "end": 1148.24, "text": "from being forwarded to your services. For some situations, this is pretty annoying, and given by"}, {"start": 1148.24, "end": 1153.68, "text": "the length of this GitHub issue, a number of other people have also encountered. There is, however,"}, {"start": 1153.68, "end": 1159.68, "text": "an unofficial solution called Docker Ingress Routing Demon, which is used in production by a few"}, {"start": 1159.68, "end": 1164.32, "text": "companies to solve this problem. I want to take a look at how well this solution works in another"}, {"start": 1164.32, "end": 1169.2, "text": "video, probably when I take a look at clustering with Docker Swarm. In any case, when it comes to my"}, {"start": 1169.2, "end": 1174.4, "text": "own personal needs, using a load balancer such as traffic works pretty well. As I mentioned at the"}, {"start": 1174.4, "end": 1178.56, "text": "start of this video, another production ready feature that Swarm provides is the ability to"}, {"start": 1178.56, "end": 1184.08, "text": "roll back a service to a previous deployment. This is useful in the event where a bug is deployed,"}, {"start": 1184.08, "end": 1188.88, "text": "but isn't severe enough to fail the health check. To show this in action, if I go ahead and change"}, {"start": 1188.88, "end": 1194.16, "text": "the image of this deployment to be one called Broken Quote, followed by then deploying it."}, {"start": 1194.16, "end": 1198.64, "text": "When I open up a web browser, you can see that the quote feature of my web app is broken,"}, {"start": 1198.64, "end": 1203.44, "text": "as the name implies. Fortunately, I'm able to roll this back pretty easily by using the Docker"}, {"start": 1203.44, "end": 1209.12, "text": "service rollback command, passing in the name of the service that I want to roll back. Now, if I"}, {"start": 1209.12, "end": 1214.32, "text": "open up my web application again, you can see that the quotes are now fixed. That covers the basic"}, {"start": 1214.32, "end": 1220.0, "text": "overview of how I use Docker Stack with my applications on a VPS. However, there's one last thing"}, {"start": 1220.0, "end": 1225.6, "text": "that I think is worth showcasing, which is how I use it for automated deployments using GitHub"}, {"start": 1225.6, "end": 1230.72, "text": "actions. To do so, let's take a look at the pipeline workflow file found inside of my guest book"}, {"start": 1230.72, "end": 1236.08, "text": "web app, where I have automated deployments set up. Here, you can see that I have the two same"}, {"start": 1236.08, "end": 1242.24, "text": "jobs that we saw before in order to test and build and push a Docker image. In addition to these,"}, {"start": 1242.24, "end": 1248.08, "text": "I also have another job called deploy, which is where the actual Docker Stack deployment takes place."}, {"start": 1248.08, "end": 1253.04, "text": "Let's go ahead and add this exact same job into my ZenStats project. Here, you'll notice that I'm"}, {"start": 1253.04, "end": 1258.24, "text": "defining the build and push step in the needs field, which means it's required to pass in order for"}, {"start": 1258.24, "end": 1264.16, "text": "this job to run. Then for the actual steps themselves inside of this job, there are two. The first is"}, {"start": 1264.16, "end": 1269.2, "text": "to check out the code at the current commit, which is pretty standard in GitHub actions. The second,"}, {"start": 1269.2, "end": 1274.88, "text": "however, is a third-party action to deploy the Docker Stack. You can find the documentation for this"}, {"start": 1274.88, "end": 1280.88, "text": "action on the GitHub actions marketplace, which provides a full list of the inputs that you can set."}, {"start": 1280.88, "end": 1285.52, "text": "Let's go ahead and take a look at these values whilst I configure it for the ZenFold.site."}, {"start": 1285.52, "end": 1290.72, "text": "First of all, let's go ahead and change the name of the stack from GEST book to ZenFold.site."}, {"start": 1290.72, "end": 1295.76, "text": "Next, you'll notice for the file property, this is actually set to docker-stack.yaml."}, {"start": 1295.76, "end": 1301.44, "text": "This file name is commonly used to differentiate between a Docker Compose configuration and a Docker Stack"}, {"start": 1301.44, "end": 1307.04, "text": "configuration. This, to me, seems like a pretty good idea, so I'm going to go ahead and rename my Docker"}, {"start": 1307.04, "end": 1313.68, "text": "Compose file to be docker-stack.yaml. Underneath the file value, we then have the host name for our Docker"}, {"start": 1313.68, "end": 1319.84, "text": "Stack deploy, which I'm going to change to be ZenFold.site. Underneath this, we have our remaining two"}, {"start": 1319.84, "end": 1326.16, "text": "values, the first of which is a user named deploy, and the second is an SSH private key, which is set"}, {"start": 1326.16, "end": 1332.48, "text": "to a GitHub secret. In order for this to work, we need to set both of these up inside of our VPS."}, {"start": 1332.48, "end": 1337.76, "text": "So let's take a look at how we can do this securely. First of all, we need to create a new user on our"}, {"start": 1337.76, "end": 1343.12, "text": "VPS. The reason I prefer to create a new user for deployments is so that I can easily limit the"}, {"start": 1343.12, "end": 1349.2, "text": "permissions this user has. This is a good security measure to limit the amount of damage if the SSH"}, {"start": 1349.2, "end": 1354.56, "text": "private key happens to be compromised. We can add a new user to this VPS by using the following add"}, {"start": 1354.56, "end": 1360.0, "text": "user command, setting the user's name. In my case, I like to use the name of deploy when it comes"}, {"start": 1360.0, "end": 1365.52, "text": "to my deployment users. Then with the user created, the next thing to do is to add them to the Docker"}, {"start": 1365.52, "end": 1370.88, "text": "group using the following user mod command. This will allow them to perform any Docker actions without"}, {"start": 1370.88, "end": 1376.56, "text": "needing elevated privileges from using pseudo. Next, we then need to create an SSH key pair for this"}, {"start": 1376.56, "end": 1382.0, "text": "user. This is achieved by using the following SSH key gen command. You'll notice that I'm doing"}, {"start": 1382.0, "end": 1387.52, "text": "this on my local machine rather than using the VPS. Once the key pair has been created, it should"}, {"start": 1387.52, "end": 1393.04, "text": "generate two files, one being our private key and the second being our public. Let's go ahead and"}, {"start": 1393.04, "end": 1398.96, "text": "add this public key into our user's authorized keys. To do so, first change into the new user on the"}, {"start": 1398.96, "end": 1405.36, "text": "VPS using the Sue command, entering in the user's password. Afterwards, we can then create the .ssh folder"}, {"start": 1405.36, "end": 1410.64, "text": "inside of their home directory using the following make-deer command. Then in order to add the SSH"}, {"start": 1410.64, "end": 1415.2, "text": "public key to their authorized keys, copy it to your clipboard and then run the following command"}, {"start": 1415.2, "end": 1420.64, "text": "to paste it into the file. With that, we should now be able to SSH into this machine as our deploy"}, {"start": 1420.64, "end": 1425.76, "text": "user, which we can test using the following command. Next, we then want to restrict what commands"}, {"start": 1425.76, "end": 1431.76, "text": "this user can actually perform via SSH. This is another good security measure, which again will"}, {"start": 1431.76, "end": 1437.36, "text": "reduce the amount of damage if the SSH key is accidentally compromised. To do so, open up the"}, {"start": 1437.36, "end": 1443.44, "text": "authorized keys file that we just created and add in the following text before the actual key itself."}, {"start": 1443.44, "end": 1448.96, "text": "This will restrict the user to only being able to perform the Docker Stack deploy command when using"}, {"start": 1448.96, "end": 1454.88, "text": "SSH with this key. Now we can test that this is the case by attempting to SSH in as our deploy user,"}, {"start": 1454.88, "end": 1459.04, "text": "which should be rejected. However, when I go to run the Docker Stack deploy command,"}, {"start": 1459.04, "end": 1464.24, "text": "this one should work. With that, we're now ready to add the private key to our GitHub repository."}, {"start": 1464.24, "end": 1469.52, "text": "To do so, navigate over to the actions secrets page found inside of the repo settings."}, {"start": 1469.52, "end": 1475.04, "text": "Then, in sub of this page, click the big green new repository secret button, which will bring us"}, {"start": 1475.04, "end": 1479.76, "text": "to a form we can create a secret with. Here, you'll want to set the name of this to be the same"}, {"start": 1479.76, "end": 1486.8, "text": "value as defined in the GitHub action, which in my case is deploy SSH private key. Then, for the"}, {"start": 1486.8, "end": 1491.6, "text": "actual secret value itself, go ahead and paste in the contents of the private key before saving"}, {"start": 1491.6, "end": 1496.56, "text": "our secret. Now, if I go ahead and commit my code followed by pushing it up, when I navigate over"}, {"start": 1496.56, "end": 1501.84, "text": "to my GitHub repo, we should see the deployments start to work with the deploy job, and it completes"}, {"start": 1501.84, "end": 1506.72, "text": "successfully. With that, our automated deployment is already set up. However, there's one last thing"}, {"start": 1506.72, "end": 1512.8, "text": "I like to do, which is to specify which image to use when it comes to deployments. If you remember,"}, {"start": 1512.8, "end": 1517.36, "text": "for each image that we build in this pipeline, we're tagging it with both the latest tag and the"}, {"start": 1517.36, "end": 1522.08, "text": "gikmid hash of the code that this image is built off. So, in order to make our deployments more"}, {"start": 1522.08, "end": 1527.28, "text": "deterministic, we want to make sure to use this same image tag. To achieve this, we can use an"}, {"start": 1527.28, "end": 1532.32, "text": "environment variable, replacing the reference to our Docker image tag in our compose yaml with the"}, {"start": 1532.32, "end": 1538.4, "text": "following syntax, which will cause it to be loaded from an environment variable named gikmid hash."}, {"start": 1538.4, "end": 1543.2, "text": "If I go ahead and set this environment variable to the last images hash and run the Docker stack"}, {"start": 1543.2, "end": 1548.4, "text": "deploy command, we should see our service deployed with the image hash we specified. In addition to"}, {"start": 1548.4, "end": 1554.4, "text": "this, we can also specify a default value for this environment variable in the case that it's not set."}, {"start": 1554.4, "end": 1559.2, "text": "This is done using the following syntax, which in this case will set the default value of the"}, {"start": 1559.2, "end": 1564.4, "text": "environment variable to be latest. With that, the last thing to do is to set this environment variable"}, {"start": 1564.4, "end": 1570.32, "text": "in our deployment pipeline. This is done by setting the EMV file option in the stack deploy action."}, {"start": 1570.32, "end": 1575.36, "text": "Then we can go ahead and create this EMV file using a step before this one. Here, we're creating a"}, {"start": 1575.36, "end": 1581.84, "text": "file with a gikmid hash environment variable set to the current github_shar_value. Now, if I commit and"}, {"start": 1581.84, "end": 1586.4, "text": "push up this code, we should see the pipeline working without issue. And we can test that it's using"}, {"start": 1586.4, "end": 1591.12, "text": "the correct image by making the following code change to the page title, committing it and"}, {"start": 1591.12, "end": 1595.84, "text": "pushing it to the github repo. Then once the pipeline completes, if I check out my deployed"}, {"start": 1595.84, "end": 1600.4, "text": "web application, we can see it's now running the new version with the updated title."}, {"start": 1600.4, "end": 1605.68, "text": "With that, we've covered the basics of how I use Docker stack when it comes to deploying on a VPS,"}, {"start": 1605.68, "end": 1610.48, "text": "including how I have it set up for automated deployments. Personally, as somebody who has come from"}, {"start": 1610.48, "end": 1616.08, "text": "mostly working with Kubernetes, I've been impressed with how lightweight yet functional Docker stack has been."}, {"start": 1616.56, "end": 1622.16, "text": "Whilst it's certainly not perfect and does come with its own caveats, so far, I found it to be a"}, {"start": 1622.16, "end": 1627.52, "text": "really good solution when it comes to running my own applications. One thing I'm still yet to try"}, {"start": 1627.52, "end": 1632.08, "text": "is setting this up to work as a cluster. But given how easy everything else has been,"}, {"start": 1632.08, "end": 1637.04, "text": "I don't expect this to be too difficult. However, that's going to be a video for another time."}, {"start": 1637.04, "end": 1640.96, "text": "So if you're interested, then please let me know in the comments down below. Otherwise,"}, {"start": 1640.96, "end": 1645.2, "text": "I want to give a big thank you to Hostinger for sponsoring this video. If you're interested in"}, {"start": 1645.2, "end": 1650.4, "text": "obtaining your own VPS instance for a super low price, then either visit the link in the description"}, {"start": 1650.4, "end": 1656.48, "text": "down below or head on over to Hostinger.com/dreamsofcode and make sure to use my coupon code \"Dreams"}, {"start": 1656.48, "end": 1661.12, "text": "of Code\" when you check out. Otherwise, I want to give a big thank you for watching and I'll see you"}, {"start": 1661.12, "end": 1662.32, "text": "on the next one."}];

    const transcriptEl = document.getElementById('transcript');
    
    function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    SEGMENTS.forEach((seg, index) => {
        const div = document.createElement('div');
        div.className = 'segment';
        div.id = `seg-${index}`;
        div.onclick = () => seekTo(seg.start);
        
        div.innerHTML = `
            <span class="timestamp">${formatTime(seg.start)}</span>
            <span class="text">${seg.text}</span>
        `;
        transcriptEl.appendChild(div);
    });

    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    var player;
    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            height: '100%',
            width: '100%',
            videoId: VIDEO_ID,
            events: {
                'onReady': onPlayerReady
            }
        });
    }

    function onPlayerReady(event) {
        startSyncLoop();
    }

    function seekTo(seconds) {
        player.seekTo(seconds, true);
        player.playVideo();
        userScrolled = false;
    }

    let activeSegmentIndex = -1;
    let userScrolled = false;
    
    transcriptEl.addEventListener('scroll', () => {
        // Basic detection: if we are scrolling, assume user interaction.
        // Ideally we'd distinguish between programmatic scroll and user scroll.
        // But for now, any scroll event disables auto-scroll until a click resets it.
        // To avoid the auto-scroll triggering this, we could use a flag.
        if (!isAutoScrolling) {
             userScrolled = true;
        }
    });
    
    let isAutoScrolling = false;

    function startSyncLoop() {
        setInterval(() => {
            if (!player || !player.getCurrentTime) return;
            
            const time = player.getCurrentTime();
            
            let currentIdx = -1;
            for (let i = 0; i < SEGMENTS.length; i++) {
                if (time >= SEGMENTS[i].start && time < SEGMENTS[i].end) {
                    currentIdx = i;
                    break;
                }
                if (time >= SEGMENTS[i].start) {
                    currentIdx = i;
                }
            }
            
            if (currentIdx !== -1 && currentIdx !== activeSegmentIndex) {
                if (activeSegmentIndex !== -1) {
                    const prev = document.getElementById(`seg-${activeSegmentIndex}`);
                    if (prev) prev.classList.remove('active');
                }
                
                const activeEl = document.getElementById(`seg-${currentIdx}`);
                if (activeEl) {
                    activeEl.classList.add('active');
                    activeSegmentIndex = currentIdx;
                    
                    if (!userScrolled) {
                        isAutoScrolling = true;
                        activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        setTimeout(() => { isAutoScrolling = false; }, 500);
                    }
                }
            }
            
        }, 200);
    }
</script>
</body>
</html>